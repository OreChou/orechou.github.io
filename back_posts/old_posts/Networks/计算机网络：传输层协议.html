<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="在计算机网络的分层协议的体系结构中，不管是 OSI 体系结构、五层体系结构还是 TCP&#x2F;IP 体系结构，它们都有传输层。传输层提供了进程间的通用数据传输服务。应用层的协议很多，定义通用的传输层协议就很重要，能够支持不断增多的应用层协议。 如下图所示，TCP&#x2F;IP 协议簇呈现沙漏的形状，TCP 和 IP 协议起到了举足轻重的作用。网络层 IP 协议提供了尽最大努力交付的功能，而要保证数据的正确传输，">
<meta property="og:type" content="website">
<meta property="og:title" content="计算机网络：传输层协议">
<meta property="og:url" content="https://orechou.github.io/back_posts/old_posts/Networks/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE.html">
<meta property="og:site_name" content="OreChou&#39;s Workspace">
<meta property="og:description" content="在计算机网络的分层协议的体系结构中，不管是 OSI 体系结构、五层体系结构还是 TCP&#x2F;IP 体系结构，它们都有传输层。传输层提供了进程间的通用数据传输服务。应用层的协议很多，定义通用的传输层协议就很重要，能够支持不断增多的应用层协议。 如下图所示，TCP&#x2F;IP 协议簇呈现沙漏的形状，TCP 和 IP 协议起到了举足轻重的作用。网络层 IP 协议提供了尽最大努力交付的功能，而要保证数据的正确传输，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://orechou.github.io/images/tcp:ip.png">
<meta property="og:image" content="https://orechou.github.io/images/UDP.png">
<meta property="og:image" content="https://orechou.github.io/source/images/tcp.png">
<meta property="og:image" content="https://orechou.github.io/images/tcp_hand_shake.png">
<meta property="og:image" content="https://orechou.github.io/images/tcp_queue.jpg">
<meta property="og:image" content="https://orechou.github.io/images/tcp_say_goodbye.png">
<meta property="og:image" content="https://orechou.github.io/images/window.png">
<meta property="og:image" content="https://orechou.github.io/images/cwnd.png">
<meta property="og:image" content="https://orechou.github.io/images/fast.png">
<meta property="article:published_time" content="2021-10-29T06:35:18.520Z">
<meta property="article:modified_time" content="2018-09-26T09:25:50.000Z">
<meta property="article:author" content="OreChou">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="TCP">
<meta property="article:tag" content="UDP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://orechou.github.io/images/tcp:ip.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>计算机网络：传输层协议</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4">
        
          <header id="header">
  <a href="/">
  
    
      <div id="logo" style="background-image: url(/images/logo.png);"></div>
    
  
    <div id="title">
      <h1>OreChou&#39;s Workspace</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">Home</a></li><!--
   --><!--
     --><li><a href="/archives/">Writing</a></li><!--
   --><!--
     --><li><a href="/book/">Book</a></li><!--
   --><!--
     --><li><a href="/game/">Game</a></li><!--
   --><!--
     --><li><a href="/gallery/">Gallery</a></li><!--
   --><!--
     --><li><a href="/about/">About</a></li><!--
   -->
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <p>在计算机网络的分层协议的体系结构中，不管是 OSI 体系结构、五层体系结构还是 TCP/IP 体系结构，它们都有传输层。传输层提供了进程间的通用数据传输服务。应用层的协议很多，定义通用的传输层协议就很重要，能够支持不断增多的应用层协议。</p>
<p>如下图所示，TCP/IP 协议簇呈现沙漏的形状，TCP 和 IP 协议起到了举足轻重的作用。网络层 IP 协议提供了尽最大努力交付的功能，而要保证数据的正确传输，需要 TCP 协议来做这个事情。</p>
<p><img src="/images/tcp:ip.png"></p>
<p>传输层一共提供了两种协议：</p>
<ul>
<li>传输控制协议</li>
<li>用户数据报协议</li>
</ul>
<span id="more"></span>

<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>用户数据报协议 UDP （User Datagram Protocol）是无连接的协议，它提供尽最大可能的交付，面向报文。没有流量控制和拥塞控制，支持一对一、一对多、多对一和多对多的通信模式。</p>
<h2 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h2><p><img src="/images/UDP.png"></p>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。在计算检验和时，要在 UDP 用户数据报之前增加 12 个字节的伪首部。“伪首部”并不是用户数据报真正的首部，只是在计算检验和时，临时添加在 UDP 数据报前面，得到一个临时 UDP 数据报。伪首部既不向下传送也不向上递交，仅仅是为了计算检验和。</p>
<p>根据 UDP 报文格式可以看出它没有像 TCP 那样的序号，所以一份 UDP 报文就是一份数据。而 IP 数据报最大长度为 65535 字节，去除 20 个 IP 首部和 8 个字节的 UDP 首部，UDP 数据报中数据的最大长度为 65507 字节。所以 UDP 是有最大报文长度限制的。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>首先明确一下 UDP 的特点，无连接、多种通信模式和具有最大报文长度的限制。无连接的具有速度快的优点，缺点是容易丢失报文，且报文一旦丢失就再也无法接收到了。所以要求实时性并且接受一定程度的数据丢失的应用场景可以使用 UDP，例如实时通讯、在线视频等。另外 UDP 支持一对多和多对多的通信模式，也可以使用在多播通信的场景中。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>传输控制协议 TCP （Transmission Control Protocol）是面向连接的协议，它提供了可靠的交付，面向字节流。具有流量控制和拥塞控制的功能，提供一对一全双工的通信模式。</p>
<h2 id="首部格式-1"><a href="#首部格式-1" class="headerlink" title="首部格式"></a>首部格式</h2><p><img src="/source/images/tcp.png"></p>
<p>TCP 的首部内容比 UDP 要多一些。首先有 20 字节的固定长度的内容：</p>
<ul>
<li><strong>源端口 &amp; 目的端口</strong></li>
<li><strong>序号 seq</strong>：当前报文的序号。TCP 是面向字节流的。比如第一个报文，会给第一个字节编上一个序号，例如 seq = 300。若报文的携带的字节流的长度为 100，那么下一个报文的 seq 则为 400。</li>
<li><strong>确认号 ack</strong>：期望收到的下一个报文的序号。例如接收方收到序号为 300，长度为 100 的报文。那么他返回的 ack 为 400。</li>
<li><strong>数据偏移</strong>：指的是数据部分距离报文起始处的偏移量，也可以当做是报文首部的长度。</li>
<li><strong>确认 ACK</strong>：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li>
<li><strong>同步 SYN</strong>：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li>
<li><strong>终止 FIN</strong>：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li>
<li><strong>窗口</strong>：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP 建立连接要经过三次握手，假设存在客户端 A 和服务端 B，它们握手的整个过程如下：</p>
<p><img src="/images/tcp_hand_shake.png"></p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>服务端 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>客户端 A 向服务端 B 发送连接请求报文，SYN=1，ACK=0，并选择一个序列号 x。</li>
<li>服务端 B 接收到请求报文，若同意建立连接，则向客户端 A 发送确认报文。并且选择一个报文序列号 y。</li>
<li>A 收到 B 的确认报文之后，向 B 发送确认报文，确认号为 y+1, 序列号为 x+1。</li>
<li>B 收到 A 的确认报文后，连接建立。</li>
</ol>
<h3 id="三次握手原因"><a href="#三次握手原因" class="headerlink" title="三次握手原因"></a>三次握手原因</h3><p>三次握手在于为了防止失效的请求连接到达服务器，让服务器以为客户端又申请连接，从而错误地打开了连接。</p>
<p>因为网络的环境是不确定的，当请求方客户端发送的请求连接报文在网络中滞留，客户端在等待超时之后会继续重新发送请求连接。若不进行三次握手，当客户端后面的请求连接建立通讯完成之后，最开始发送的滞留报文被传递给了服务端。服务端会以为客户端申请了新的连接，从而打开连接占用资源。若使用三次握手，服务端就会去确认这个请求连接是否是客户端要发起建立的，避免错误地打开连接。</p>
<h3 id="半连接和全连接队列"><a href="#半连接和全连接队列" class="headerlink" title="半连接和全连接队列"></a>半连接和全连接队列</h3><p>TCP 请求中有两个队列，半连接队列（syns queue）和全连接队列，如下图所示：</p>
<p><img src="/images/tcp_queue.jpg"></p>
<p>在握手的第一步中，服务端接收到连接的请求后，会将相关的信息存储到半连接队列中。</p>
<p>在握手的最后一步，服务端接收到客户端的 ACK 后，会将相关信息从半连接队列中取出存入到全连接队列中。</p>
<p>syn floods 攻击就是针对 TCP 半连接队列，导致该队列满，从而无法接受其他正常的连接请求。</p>
<p>当服务端接收到连接请求时，发现全连接队列满已满，那么服务端会过一段时间才会发送 FIN ACK 报文给请求方。</p>
<p>队列长度可以通过 backlog 参数进行设置。我在这里理解的长度是半连接队列 + 全连接队列的参考长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>TCP 断开连接需要进行四次挥手，整个挥手的过程如下：</p>
<p><img src="/images/tcp_say_goodbye.png"></p>
<h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>假设客户端 A 首先发送完数据。</p>
<ol>
<li>客户端 A 会发送终止报文，FIN=1，序列号为 u。此刻 A 会进入FIN-WAIT-1 的状态。</li>
<li>服务端 B 收到终止报文后发送确认报文，此时 TCP 处于半关闭状态，B 可以向 A 发送数据但 A 不能向 B 发送数据。B 进入 CLOSE-WAIT 状态。</li>
<li>客户端 A 收到 B 的确认报文之后，进入 FIN-WAIT-2 的状态，并接受 B 未传递完的数据。</li>
<li>当 B 发送完数据之后发出终止报文，进入 LAST-ACK 状态。</li>
<li>A 接收到 B 的终止报文后，发出确认报文。并进入 TIME-WAIT 状态。</li>
<li>B 收到确认报文后关闭连接，若 A 在 TIME-WAIT 状态下等待 2MSL 时间未收到 B 的重传报文，则关闭连接。</li>
</ol>
<h3 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h3><p>进行四次挥手的原因在于，TCP 的通讯是全双工的，通信的双方都需要发送一次终止连接的报文，而接受的另一方需要发送确认报文才可以告知对面我已经收到断开报文的请求。</p>
<h3 id="等待-2MSL-原因"><a href="#等待-2MSL-原因" class="headerlink" title="等待 2MSL 原因"></a>等待 2MSL 原因</h3><p>MSL（Maximum Segmet Lifetime）指的是报文在网络中能够存在的最长时间。</p>
<p>客户端处于 FIN-WAIT-2 状态时收到服务端的终止报文后悔进入 TIME-WAIT 状态，并等待两个 MSL，这样做的原因有两个：</p>
<ol>
<li>确保最后一个确认报文能够被对方接受。若 B 未接收到 A 发送的确认报文，那么 B 就会重新发送终止报文给 A。A 若再次收到终止报文，那么就知道 B 并没有接收到 A 的确认报文，就能够继续发送。</li>
<li>等待的这段时间内可以确认这次连接中所发送的所有报文都会在网络中消失，当建立下一次连接的时候，可以确定不会接收到上一次连接中所发送的报文。</li>
</ol>
<h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p>TCP 相比与 UDP 最大的不同就是，TCP 能够保证传输是可靠的。可靠传输通过超时重传、校验和、流量控制、拥塞控制来实现。</p>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>发送方发送一个报文后，会启动一个定时器。若已个已经发送的报文在超时时间内没有收到确认，那么就重传这一个报文。</p>
<h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><p>TCP 报文头部中有部分是根据首部和数据计算的校验和，接收方可以计算校验和然后这个校验和相比较，判断数据在整个传输的过程中是否发生了变化。若接收方接收到的校验和有差错，那么就丢弃该报文，让发送方再次重传。</p>
<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>流量控制和拥塞控制都要基于滑动窗口的机制。</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>窗口属于缓存，用来暂存字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<p><img src="/images/window.png"></p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>TCP 拥塞控制目的在于当网络中出现了拥塞，若发送方继续重传报文和发送新报文，则会导致网络中的拥塞程度变得更高。所以当网络出现拥塞的时候，需要控制发送方的速率。</p>
<p>TCP 通过四个方法来进行拥塞控制：满开始、拥塞避免、快重传、快恢复。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<h5 id="慢开始-amp-拥塞避免"><a href="#慢开始-amp-拥塞避免" class="headerlink" title="慢开始 &amp; 拥塞避免"></a>慢开始 &amp; 拥塞避免</h5><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
<p><img src="/images/cwnd.png"></p>
<h5 id="快重传-amp-快恢复"><a href="#快重传-amp-快恢复" class="headerlink" title="快重传 &amp; 快恢复"></a>快重传 &amp; 快恢复</h5><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<p><img src="/images/fast.png"></p>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2022
    OreChou
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/book/">Book</a></li><!--
     --><!--
       --><li><a href="/game/">Game</a></li><!--
     --><!--
       --><li><a href="/gallery/">Gallery</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
