<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Java IO 相关的文章，在网络上可以搜索到一大堆，并且 《Java NIO》和《Netty 权威指南》两本书可以包读者从入门到进阶。写这篇文章的目的在于让自己总结一下 Java IO 知识，从总结中学习。 Java 的 IO 大致可以分为如下几类：  磁盘操作：File 字节操作：InputStream &amp; OutputStream 字符操作：Reader &amp; Writer 网">
<meta property="og:type" content="website">
<meta property="og:title" content="Java NIO">
<meta property="og:url" content="https://orechou.github.io/back_posts/old_posts/Java/Java%20NIO.html">
<meta property="og:site_name" content="OreChou&#39;s Workspace">
<meta property="og:description" content="Java IO 相关的文章，在网络上可以搜索到一大堆，并且 《Java NIO》和《Netty 权威指南》两本书可以包读者从入门到进阶。写这篇文章的目的在于让自己总结一下 Java IO 知识，从总结中学习。 Java 的 IO 大致可以分为如下几类：  磁盘操作：File 字节操作：InputStream &amp; OutputStream 字符操作：Reader &amp; Writer 网">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://orechou.github.io/images/buffer_1.png">
<meta property="og:image" content="https://orechou.github.io/images/buffer_2.png">
<meta property="og:image" content="https://orechou.github.io/images/buffer_3.png">
<meta property="og:image" content="https://orechou.github.io/images/buffer_4.png">
<meta property="og:image" content="https://orechou.github.io/images/buffer_5.png">
<meta property="og:image" content="https://orechou.github.io/images/buffer_6.png">
<meta property="og:image" content="https://orechou.github.io/images/nio_selector.png">
<meta property="og:image" content="https://orechou.github.io/images/reactor.png">
<meta property="og:image" content="https://orechou.github.io/images/reactor_1.png">
<meta property="og:image" content="https://orechou.github.io/images/reactor_2.png">
<meta property="og:image" content="https://orechou.github.io/images/reactor_3.png">
<meta property="article:published_time" content="2021-10-29T06:35:18.520Z">
<meta property="article:modified_time" content="2018-09-16T14:52:38.000Z">
<meta property="article:author" content="OreChou">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://orechou.github.io/images/buffer_1.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Java NIO</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4">
        
          <header id="header">
  <a href="/">
  
    
      <div id="logo" style="background-image: url(/images/logo.png);"></div>
    
  
    <div id="title">
      <h1>OreChou&#39;s Workspace</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">Home</a></li><!--
   --><!--
     --><li><a href="/archives/">Writing</a></li><!--
   --><!--
     --><li><a href="/book/">Book</a></li><!--
   --><!--
     --><li><a href="/game/">Game</a></li><!--
   --><!--
     --><li><a href="/gallery/">Gallery</a></li><!--
   --><!--
     --><li><a href="/about/">About</a></li><!--
   -->
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <p>Java IO 相关的文章，在网络上可以搜索到一大堆，并且 《Java NIO》和《Netty 权威指南》两本书可以包读者从入门到进阶。写这篇文章的目的在于让自己总结一下 Java IO 知识，从总结中学习。</p>
<p>Java 的 IO 大致可以分为如下几类：</p>
<ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream &amp; OutputStream</li>
<li>字符操作：Reader &amp; Writer</li>
<li>网络操作：Socket</li>
</ul>
<p>最开始 Java 只提供了 BIO（Block IO），Block IO 的意思是线程调用 IO 操作的时候，线程会阻塞等待 IO 完成。在这个期间，线程除了等待无法完成其他的事情。因为这种 IO 模式，之前的 Java 框架在编写服务器的时候，会对每一个 Socket 的请求新建一个线程进行处理。因为线程的新建与销毁是需要消耗系统资源的，所以若系统频繁地创建与销毁线程，那么会对系统资源造成很大的浪费。在这种 IO 模式下的改进方式是利用池化技术，通过线程池的方式来管理线程，减少线程频繁创建和销毁的开销。但是并没有改变最根本的问题，即一个服务请求的连接都需要一个线程来处理，在高并发的情况下，阻塞 IO 的实现肯定无法满足性能的需求。</p>
<p>针对这一问题，在 JDK 1.4 中 NIO 就登场了。</p>
<span id="more"></span>

<p>很多人将 NIO 称为 New IO 或者 Not Block IO，后者应该更贴切一点。</p>
<p>首先是 NIO 里面有哪些东西。</p>
<h2 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h2><h3 id="Buffer（缓冲区）"><a href="#Buffer（缓冲区）" class="headerlink" title="Buffer（缓冲区）"></a>Buffer（缓冲区）</h3><p>NIO 处理的数据存储在 Buffer 里，一个 Buffer 对象是一个固定数量的数据容器，也可以视作数据传输的来源或者目标。</p>
<h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><p>缓冲区的几个属性如下：</p>
<ul>
<li>Capacity（容量）：在创建时设定，无法在后续修改。表示能够容纳的数据元素的最大数量。</li>
<li>Limit（上界）：缓冲区中现存元素的计数，也表示了第一个不能读写的元素的位置。</li>
<li>Position（位置）：下一个要读或者要写的位置。</li>
<li>Mark（标记）：一个备忘的位置。</li>
</ul>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><h5 id="新建-Buffer"><a href="#新建-Buffer" class="headerlink" title="新建 Buffer"></a>新建 Buffer</h5><p>假设创建一个容量为 10 的缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// capacity: 10</span></span><br><span class="line"><span class="comment">// limit: 10</span></span><br><span class="line"><span class="comment">// position: 0</span></span><br><span class="line"><span class="comment">// mark: x</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/buffer_1.png"></p>
<h5 id="填充-Buffer"><a href="#填充-Buffer" class="headerlink" title="填充 Buffer"></a>填充 Buffer</h5><p>向缓冲区填充 5 次数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer.put((<span class="keyword">byte</span>)<span class="string">&#x27;H&#x27;</span>).put((<span class="keyword">byte</span>)<span class="string">&#x27;e&#x27;</span>).put((<span class="keyword">byte</span>)<span class="string">&#x27;l&#x27;</span>).put((<span class="keyword">byte</span>)<span class="string">&#x27;l&#x27;</span>).put((<span class="keyword">byte</span>)<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="comment">// capacity: 10</span></span><br><span class="line"><span class="comment">// limit: 10</span></span><br><span class="line"><span class="comment">// position: 5 (即可视为当前 put 到数据中的数量，也可视为下个元素 put 的位置)</span></span><br><span class="line"><span class="comment">// mark: x</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/buffer_2.png"></p>
<h5 id="翻转-Buffer"><a href="#翻转-Buffer" class="headerlink" title="翻转 Buffer"></a>翻转 Buffer</h5><p>当我们要去读取 Buffer 的时候，我们需要翻转（flip） Buffer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.flip();</span><br><span class="line"><span class="comment">// 代码等价于如下，即把 limit 位置设置成 position的位置，再将 position 设置为 0</span></span><br><span class="line">buffer.limit(buffer.position()).position(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/buffer_3.png"></p>
<h5 id="压缩-Buffer"><a href="#压缩-Buffer" class="headerlink" title="压缩 Buffer"></a>压缩 Buffer</h5><p>当读取缓冲区中两个元素之后，缓冲区如下。</p>
<p><img src="/images/buffer_4.png"></p>
<p>此刻从缓冲区中释放一部分数据，而不是全部，然后重新填充。为了实现这一点，未读的数据元素需要下移以使第一个元素索引为 0。从而将 Buffer 进行压缩（compact）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.compact();</span><br></pre></td></tr></table></figure>

<p><img src="/images/buffer_5.png"></p>
<p>根据图示，数据元素 2-5 被复制到 0-3 位置，4 以后的位置超出了 position，所以在后面 buffer 写入数据的时候被覆盖掉。</p>
<h5 id="标记-Buffer"><a href="#标记-Buffer" class="headerlink" title="标记 Buffer"></a>标记 Buffer</h5><p>使用标记函数将 mark 设置为当前 position 的值。当我们需要重复读取 Buffer 中某段数据的时候会可以派上用场。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.position(<span class="number">2</span>).mark().position(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/buffer_6.png"></p>
<h3 id="通道（Channel）"><a href="#通道（Channel）" class="headerlink" title="通道（Channel）"></a>通道（Channel）</h3><p>通道位于缓冲区与通信的另一方（文件或 socket）之间，提供全双工的数据传输。JDK 1.4 提供的通道种类如下：</p>
<ul>
<li>FileChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
<li>DatagramChannel</li>
</ul>
<p>打开 FileChannel 必须通过在 RandomAccessFile、FileInputStream 和 FileOutputStream 对象上调用 getChannel。而另外三个关于 socket 的通道则可以通过相应的静态工厂方法打开。原因在于，创建文件通道的时候，一定要有明确的文件目标，即先有了目标文件才去与之建立数据的通道。一个打开的文件通道对应了一个文件描述符。而开启 Socket 通道的时候还不知道谁来建立连接，与谁建立连接。</p>
<p>Socket 通道可以选择两种模式，阻塞模式和非阻塞模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel sc = SocketChannel.open( );</span><br><span class="line">sc.configureBlocking (<span class="keyword">false</span>); <span class="comment">// nonblocking</span></span><br></pre></td></tr></table></figure>

<p>NIO Socket 提供的非阻塞模式，是编写高性能 IO 应用的关键。对于 Java 编写的服务器来说，能够实现单线程对多个 Socket 连接的管理，并且方式简单。</p>
<h3 id="选择器（Selector）"><a href="#选择器（Selector）" class="headerlink" title="选择器（Selector）"></a>选择器（Selector）</h3><p>通过将通道注册到选择器 Selector上，并绑定相关的事件，在后面就可以通过选择器找到这些通道就绪的相关事件。SelectionKey 封装了一个通道和选择器的注册关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step 1</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">// step 2</span></span><br><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 通道必须设置为非阻塞的模式</span></span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT); <span class="comment">// 这里注册了接受事件</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// step 3</span></span><br><span class="line"><span class="comment">// 当有就绪的通道的时候，我们可以调用 selectedKeys() 方法获取到这些 key，并进行处理</span></span><br><span class="line"><span class="keyword">int</span> num = selector.select();</span><br><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件的种类如下：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看出每个事件可以被当成一个位域，从而组成事件集整数</span></span><br><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<p>Selector 的原理图如下：</p>
<p><img src="/images/nio_selector.png"></p>
<h2 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><p>当使用 NIO 编写 Java 服务器相关的程序的时候，通常会采用名为 Reactor 的设计模式。</p>
<blockquote>
<p>Wikipedia: The reactor design pattern is an event handling pattern for handling service requests delivered concurrently by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to associated request handlers.</p>
</blockquote>
<p>画个图如下所示：</p>
<p><img src="/images/reactor.png"></p>
<p>从图中可以看出当有外部事件发生后，这些事件发送给 Service Handler，Service Handler 的作用是做一个分发，将这些请求分发给具体的 Handler 进行处理。</p>
<p>那么将 Reactor 模式应用到 NIO 的服务器编程上，可以有三种方案。</p>
<h3 id="单线程-Reactor"><a href="#单线程-Reactor" class="headerlink" title="单线程 Reactor"></a>单线程 Reactor</h3><p><img src="/images/reactor_1.png"></p>
<p>Reactor 线程要做很多事情，包括：</p>
<ul>
<li>接受请求，注册事件</li>
<li>将就绪事件分别处理</li>
</ul>
<p>这种模式下，Reactor 线程又要维护连接，又要做相应的工作。</p>
<h3 id="带线程池的-Reactor"><a href="#带线程池的-Reactor" class="headerlink" title="带线程池的 Reactor"></a>带线程池的 Reactor</h3><p><img src="/images/reactor_2.png"></p>
<p>单线程 Reactor 模式，最直观的改进方式就是在事件处理的部分引入工作队列 + 线程池。我们将就绪任务进行分类，对每一种类别的任务，提交到专属的线程池中去处理。这样 Reactor 线程只需要做接受请求，注册监听事件的任务。而任务的处理提交给其他线程，不仅可以减小 Reactor 的压力，也能够提高任务处理的速度。</p>
<h3 id="主从多-Reactor"><a href="#主从多-Reactor" class="headerlink" title="主从多 Reactor"></a>主从多 Reactor</h3><p><img src="/images/reactor_3.png"></p>
<p>使用一个 Reactor 线程来接受请求，注册监听所有的读写事件，当读写事件变多时，但线程可能无法满足性能的需求。可以引入了多 Reactor，也即一个主 Reactor 负责监控所有的连接请求，多个子 Reactor 负责监控并处理读/写请求，减轻了主 Reactor 的压力，降低了主 Reactor 压力太大而造成的延迟。并且每个子 Reactor 分别属于一个独立的线程，每个成功连接后的 Channel 的所有操作由同一个线程处理。这样保证了同一请求的所有状态和上下文在同一个线程中，避免了不必要的上下文切换，同时也方便了监控请求响应状态。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java NIO 的实现基于底层操作系统提供的相关 API，例如 Linux 提供了 select、poll、epoll 等系统调用。Java NIO 无疑为编写的 IO 程序提高了性能，但是其缺点在于实现复杂，维护和管理困难。这也是 Netty 框架致力于解决的缺点。</p>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2022
    OreChou
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/book/">Book</a></li><!--
     --><!--
       --><li><a href="/game/">Game</a></li><!--
     --><!--
       --><li><a href="/gallery/">Gallery</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9RBGC8GJC6"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-9RBGC8GJC6');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
