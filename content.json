{"meta":{"title":"OreChou's Batcave","subtitle":"Coding & Reading & Playing & Listening","description":"Coding 💻 & Reading 📖 & Playing 🎮 & Listening 🎧\n It's not who I am underneath, but what I do that defines me.","author":"OreChou","url":"https://orechou.live","root":"/"},"pages":[{"title":"Gallery Of My Life.","date":"2023-02-19T08:11:21.936Z","updated":"2023-02-19T08:11:20.813Z","comments":true,"path":"gallery/index.html","permalink":"https://orechou.live/gallery/index.html","excerpt":"","text":"西门🐱：Pikachu"},{"title":"Games Of My Life.","date":"2023-02-11T13:50:53.000Z","updated":"2022-05-13T16:25:55.000Z","comments":true,"path":"game/index.html","permalink":"https://orechou.live/game/index.html","excerpt":"","text":"喜欢的游戏【1】Batman: Arkham Knight很喜欢在暴雨、黑夜中的哥谭市，扮演这位黑暗骑士的感觉。孤独、隐忍与信念。 【2】Middle-earth: Shadow of Mordor原创的一个刚铎游侠为守卫世界最后成为戒灵的故事。复仇、纠结与牺牲。游戏的结尾曲感人。 【3】Red Dead Redemption 2Read Dead Redemption 2 可以无限吹，18 年最佳游戏落败给战神 4 我是没想到的。"},{"title":"About me.","date":"2023-03-05T13:19:50.305Z","updated":"2023-03-05T13:19:47.587Z","comments":true,"path":"about/index.html","permalink":"https://orechou.live/about/index.html","excerpt":"","text":"MeaningCoding 💻 &amp; Reading 📖 &amp; Playing 🎮 &amp; Listening 🎧It’s not who I am underneath, but what I do that defines me.希望能够体验、记录更多的生活。构建这个博客小站，是为了让人看到，希望能交到一些朋友。😄 Location0 ~ 25 years，重庆25 ~ Now, 深圳在重庆完成学业之后就来到深圳工作，从一个极 🌶 的城市到现在只能吃 🥥🐔，生活上的变化还是蛮大的。 Career2019.7 ~ 2021.6 维沃移动通信(深圳)有限公司|影像系统集成开发部|应用工程师负责影像相关的软件重构；图像图像渲染；预览平滑 VSYNC 优化；获创新奖、优秀奖。 2021.6 ~ 至今 牛客|企业服务部|后端工程师业务方向牛客企业端 saas 服务；负责牛客题库中台；负责牛客竞赛。 Education2012 ~ 2016 重庆大学|计算机学院|计算机科学与技术|本科2016 ~ 2019 重庆大学|计算机学院|计算机科学与技术|硕士 毕业课题相关的发布了三篇 CCF-C 类的会议论文，分别是：Spatially fine-grained air quality prediction based on DBU-LSTMA Novel Approach for Air Quality Inference and Prediction Based on DBU-LSTMDeep Spatial-Temporal Fusion Network for Fine-Grained Air Quality Prediction"},{"title":"Books Of My Life.","date":"2023-04-09T14:25:43.188Z","updated":"2023-04-09T14:25:40.324Z","comments":true,"path":"book/index.html","permalink":"https://orechou.live/book/index.html","excerpt":"","text":"2023 年度四月份No.1《富爸爸杠杆致富》豆瓣链接🔗看完了朋友推荐的这本书，猛灌了很多鸡汤。有几点还是很启发我，一要关注自己使用的词汇；二要拓展自己的现实；三要熟悉各种杠杠，明白风险和冒险是两回事；四财务问题是心智、计划和行动的问题，关注这三个方面。希望能提早鼓起勇气吧。 三月份No.1《高胜率期权交易心法》豆瓣链接🔗一本讲期权交易策略的书，主要介绍的策略是 short put option，预留足够的安全边际的高胜率策略。主要的思路是利用期权定价模型的不准确，利用风险的不对称性，高胜率地赚钱。在周报中介绍了一下读书笔记，🔗为：【Cyber Weekly】No.5 The Curious Case of Benjamin Button No.2《当下的力量》豆瓣链接🔗人不活在过去，也不活在未来，只活在当下。断断续续用了一个月的时间翻看完了这本书，按照序言里面的推荐，阅读这本书不要思考，这是一种很惊人的说法。另外书中认为思维是意识的枷锁，让人难以进入到当下。做自己思维的观察者，别做一个无意识的人。 二月份No.1《蛤蟆先生去看心理医生》豆瓣链接🔗恭喜蛤蟆先生找到了自我，走出了抑郁的阴影。有人会认为童年的不幸将会用一生来治愈，这种观念有点夸张，但童年对人影响巨大是毫无疑问的。我的成长中也经历了很多事情，让事情过去的方式，也只是让事情过去。我挺希望年轻时候能早点明白人格生成的原因，个人所处的心理状态，并知晓对应处理和转变观念的方式，或许能让自己心态没那么沉重。现在的生活也是考验，我希望我有“我好，你也好”的这种信念，让生活变美起来。 No.2《从程序员到架构师：大数据量 缓存、高并发、微服务 多团队协同等核心场景实战》豆瓣链接🔗作者以自身的工作经历出发，结合实际的业务场景、技术背景来介绍了系统服务所遇到的问题，和相应的架构解决思路。有些点其实在工作中也能遇到，有相应体会。 No.3《卓有成效的工程师》豆瓣链接🔗读书笔记🔗：【读书】《卓有成效的工程师》这是一本面向程序员工程师的一本成长类的书籍，给出了成为一个高效率工程师或团队的方法论。对于个人来说，书中给出了一个杠杆率的可计算的指标，杠杆率 = 工作产生的影响 / 投入的时间，可以理解投资回报率。我们应该去做那些杠杆率高的事情。另外学习方式、任务优先级、投资迭代速度和想法验证等问题也是值得去关注的。不过后续的章节有些内容是交叉的，有些冗余。 一月份No.1《卡片笔记写作法》豆瓣链接🔗一篇不错的笔记方法论书籍。"},{"title":"Words Of Saying.","date":"2023-04-23T14:45:18.198Z","updated":"2023-04-23T14:45:12.616Z","comments":true,"path":"saying/index.html","permalink":"https://orechou.live/saying/index.html","excerpt":"","text":"“总有那么一天”，这个借口会像疾病一样，将你的梦想和你一起带进坟墓。不断地权衡利弊也没有意义，如果这对你来说很重要，而且“最终”你会这么做，那么现在就做吧，边做边调整。—— 《每周工作4小时》"}],"posts":[{"title":"JUC 工具：LockSupport","slug":"java/JUC-tools-LockSupport","date":"2023-06-09T09:00:00.000Z","updated":"2023-06-09T07:20:01.834Z","comments":true,"path":"java/JUC-tools-LockSupport/","link":"","permalink":"https://orechou.live/java/JUC-tools-LockSupport/","excerpt":"","text":"简介LockSupport 是 Java 并发工具包 java.util.concurrent 中的一个用于创建锁和其他同步类的基本线程阻塞原语。LockSupport 提供了 park() 和 unpark() 方法来停止和恢复线程。这些方法比低级的 wait/notify 和 notifyAll 方法更容易使用，并且与 java.util.concurrent 的高级同步工具更好地互相配合。 示例在下面这个例子中，我们定义了两个线程。t1 打印数字，t2 打印字母。我们想要实现的效果是 t1 和 t2 交替打印，即输出结果为 “1A2B3C4D5E6F7G”。使用 LockSupport 的 park() 和 unpark() 方法，我们可以精确地控制线程的执行顺序，实现线程间的同步。 1234567891011121314151617181920212223242526272829import java.util.concurrent.locks.LockSupport;public class LockSupportDemo &#123; static Thread t1 = null, t2 = null; public static void main(String[] args) &#123; char[] a1 = &quot;1234567&quot;.toCharArray(); char[] a2 = &quot;ABCDEFG&quot;.toCharArray(); t1 = new Thread(() -&gt; &#123; for (char c : a1) &#123; System.out.print(c); LockSupport.unpark(t2); // 叫醒t2 LockSupport.park(); // 阻塞t1 &#125; &#125;, &quot;t1&quot;); t2 = new Thread(() -&gt; &#123; for (char c : a2) &#123; LockSupport.park(); // 阻塞t2 System.out.print(c); LockSupport.unpark(t1); // 叫醒t1 &#125; &#125;, &quot;t2&quot;); t1.start(); t2.start(); &#125;&#125; 答疑Q1：park 方法中的 blocker 的作用这个 blocker 参数实际上是一个与该挂起操作关联的对象，这个对象会在调用 park() 方法后被设置到该线程，用于后续诊断和监控工具查看。它并不参与 park() 方法的工作逻辑，也不会影响挂起或者恢复线程的操作。这个对象通常是执行该操作的同步抽象（例如锁）。在调用 park 方法之后，可以使用 getBlocker(Thread) 方法来检索和清除该对象。 总的来说，blocker 对象主要是用于诊断和监控目的，它能帮助开发者或者工具更好地理解线程为何被挂起，以及哪个对象是造成线程挂起的原因。 Q2：LockSupport 相比于 Object.wait 和 Object.notify 的优势LockSupport 相较于 Object.wait 和 Object.notify 提供了更高级、更安全、更灵活的线程同步机制，主要体现在以下几点： 无需在同步代码块里：调用 LockSupport 的 park() 和 unpark() 方法不需要在 synchronized 代码块中，避免了不必要的同步，比较灵活。 中断影响：如果线程正在调用 park() 阻塞，那么如果其他线程中断它，那么 park() 方法会返回，但不会抛出 InterruptedException 异常。 提供了 blocker 的概念：LockSupport 可以知道是因为什么原因导致线程被阻塞，这对于问题排查等方面会更有帮助。 unpark 可以先于 park 调用：在 Object.wait 和 Object.notify 中，必须先执行 wait 再执行 notify，否则 notify 的作用会丢失，而 LockSupport 则允许 unpark 先执行。 Q3: LockSupport.park()会释放锁资源吗不会。LockSupport.park() 方法只是让当前线程进入等待状态，它不会释放任何线程可能持有的锁。这是因为，LockSupport.park() 是一个底层的线程阻塞工具，而不涉及 Java 的同步控制块（即 synchronized 关键字）或者 java.util.concurrent 包中的高级锁工具。在使用 LockSupport.park() 时，需要特别注意这一点。如果一个线程在持有锁的情况下调用了 park() 方法并被阻塞，那么可能会导致其他试图获取该锁的线程也被阻塞，从而可能引发活跃性问题。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://orechou.live/tags/Java/"},{"name":"JUC","slug":"JUC","permalink":"https://orechou.live/tags/JUC/"}]},{"title":"Kafka 消息大量积压的一些总结","slug":"web/Kafka 消息大量积压的一些总结","date":"2023-06-03T08:30:00.000Z","updated":"2023-06-03T08:29:48.519Z","comments":true,"path":"web/Kafka 消息大量积压的一些总结/","link":"","permalink":"https://orechou.live/web/Kafka%20%E6%B6%88%E6%81%AF%E5%A4%A7%E9%87%8F%E7%A7%AF%E5%8E%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/","excerpt":"","text":"本文主要总结一些 Kafka 作为消息队列使用时，当线上出现消息大量积压后的处理方法以及平时使用时应该注意的点。一般从三个方向排查分析问题，消费者的问题、分区设计的问题和网络问题。 消费者导致大部分消息积压基本都是消费者出现了状况，消费者处理的速度慢、或者消费者出现了故障。确认消费者出现问题后，我们首先要做的就是恢复或者提高消费速度。 提高消费速度一般来说，我们会对消息队列里面消息数量做监控，当消息到达一定阈值的时候，自动化地去对消费者的数量扩容。但是因为 Kafka 的 Topic 的 Partition 数量是有限制的，当消费者的数量扩容到 Partition 数量之后，再对消费者数量进行增加就没有作用了。如果这时并没有解决消费者速度的问题，我们需要能够快速把消费的能力再放大，相应的步骤如下： 问题修复: 先解决消费者的问题，以恢复消费速度，随后停止所有消费者。 新建 Topic: 创建一个新 Topic，其 Partition 数量是原先的 10 倍，并且创建相应数量的队列。一般不直接对原 Topic 的分区进行调整，因为分区增加之后没有办法去缩小。 数据分发: 编写并部署一个临时的消费者程序，此程序将积压的数据消费后，不进行耗时处理，而是均匀分发至新创建的队列中。 并发消费: 临时增加 10 倍的消费者机器，每一批消费者消费一个临时队列的数据，相当于以原本的10倍速度消费数据。 架构恢复: 在积压数据消费完后，恢复原始架构，重新用原先的消费者机器来消费消息。 上面的方法能够快速地解决线上堆积了大量的消息。除此之外，我们对消费者的设计也会影响到消费的速率。 其他的注意点控制消费者获取消息的数量Kafka 支持批量消费数据。在消费者端，可以通过修改配置参数来改变每次从 Kafka 服务器获取的消息数量。这主要通过以下两个配置参数控制： fetch.min.bytes: 消费者从服务器获取的最小数据，如果不满足这个值，消费者会等待直到满足此值。 fetch.max.wait.ms: 消费者等待 Kafka 服务端积累数据的最长时间。还有一个与之相关的参数： max.poll.records：它能够控制消费者每次调用 poll() 时返回的最大记录数。 以上三个参数都是在实时性和吞吐量之间进行权衡的，你可以根据业务需求，对这些参数进行适当的调整。在调整这些参数之前，最好先在测试环境中进行性能测试，以确定最佳的参数设置。 如果你的业务场景对实时性要求较高，即希望消息一生成就能尽快被消费，那么 fetch.min.bytes 可以设置得较小，fetch.max.wait.ms 也可以设置得较小，这样可以确保消费者能够更快地获取到新的消息。 如果你的业务场景对吞吐量要求较高，即希望消费者能够以较高的速度处理大量的消息，那么 fetch.min.bytes 可以设置得较大，fetch.max.wait.ms 也可以设置得较大，这样可以通过增加每次获取的消息数量，提高消费者的处理效率。 max.poll.records 参数用于控制每次调用poll()时返回的最大记录数。如果你希望消费者每次能处理更多的消息，可以增大这个值。但是，这个值的增大可能会增加消费者处理消息的延迟。 优化消费者的处理逻辑对于消费者的处理代码，优化其代码逻辑。有以下的点可以考虑： 是否能够使用多线程来加快业务逻辑的处理速度； 是否能够减少数据库的调用次数； 是否能够减少下游 PRC 调用的次数。 分区设计不合理导致观察 Kafka 的消费在不同的 Partition 上的消息堆积情况，如果消息主要分布在部分 Parition 上，那么我们也许要确认是否是分区设计不合理导致。如果是的话，可能需要重新设计分区策略。比如，考虑使用更细粒度的key进行分区，或者增加总的分区数。 网络带宽瓶颈导致如果网络带宽不足，可能导致消费者无法及时拉取数据。如果是硬件或者网络瓶颈，可以考虑扩容硬件或者升级网络。另外开启消息压缩，可以减少网络传输和磁盘存储的压力，通过 compression.type 可以设置压缩算法。","categories":[],"tags":[{"name":"middleware","slug":"middleware","permalink":"https://orechou.live/tags/middleware/"},{"name":"Kafka","slug":"Kafka","permalink":"https://orechou.live/tags/Kafka/"}]},{"title":"何时退休（一）：先做一个财务自由计划","slug":"investment/何时退休（一）：先做一个财务自由计划","date":"2023-04-16T15:30:00.000Z","updated":"2023-04-16T16:10:52.199Z","comments":true,"path":"investment/何时退休（一）：先做一个财务自由计划/","link":"","permalink":"https://orechou.live/investment/%E4%BD%95%E6%97%B6%E9%80%80%E4%BC%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%85%88%E5%81%9A%E4%B8%80%E4%B8%AA%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E8%AE%A1%E5%88%92/","excerpt":"","text":"I think it the excitement only a free man can feel, a free man at the start of a long journey whose conclusion is uncertain. I hope the Pacific is as blue as it has been in my dreams. 人生这趟旅途，如果提早确定自己的目标、做好有用的计划，就会有更多的时间、精力来享受自己的人生。而在当下，很多人因为钱的问题走在自己不喜欢的路途上。我父辈的这一代，大部分人从事教师和医生的职业，在一个县城工作或奉献了自己大部分的人生。他们的思想更加关注工作的稳定、收入的高低、福利的好坏，关注绩效工资、关注退休金等等。我从小接受的教育是搞好成绩，考个大学，当个白领。我很自然地就这样做了，但实际上工作的越久，人生的多样性越单一。具体的，工资越高，债务越高；年龄越大，压力越大。久而久之就会为了金钱的事情妥协，做一些不喜欢的事情。每个行业高速发展的福利期过去了，按部就班的工作也能搭上一辆车，驶向财务自由的机率也变低了。所以何时退休，如何摆脱不想做的事情，先做一个财务自由计划是关键的第一步。 财务自由和财富自由做计划前需要先分清楚财务自由（Financial Freedom）和财富自由（Wealth Freedom）是两个相关但略有不同的概念。财务自由意味着非劳动的收入足以支付你的日常生活开支，无需依赖工作收入。而财富自由意味着你拥有足够的财富，可以实现你的梦想、目标和愿望，过上奢华的生活，不仅仅是满足基本生活需求。两种自由的标准和程度是不一样的。 我们先定义收入类型，主要有三种收入类型： 工作收入：劳动获得的收入，如上班的薪酬等。 证券收入：来源于纸资产，如股票、债券和共同基金等。 被动收入：来源于非纸资产，如房产出租所带来的租金，专利或者知识产权产品的收入等。 在上面的收入类型中，学会获取被动收入和证券收入的速度越快，年轻富有地退休就会越快。 财务自由公式实现财务自由，我们可以使用一个简化的公式。 退休本金 = ((年度总支出 - 年度总被动收入) * (1 - (1 + (年化收益率 - 通货膨胀率))^(-退休年限))) / (年化收益率 - 通货膨胀率) 公式中，年度总支出、年度总被动收入很好理解。年化收益率和通货膨胀率大家也基本知晓。公式中的 (1 - (1 + (年化收益率 - 通货膨胀率))^(-退休年限))：这一部分表示了从退休开始到退休结束这段时间内，本金逐渐减少的比例。我们假设在退休期间的最后一年，本金刚好用完，所以用 1 减去剩余本金比例，得到消耗掉的本金比例。 年化收益率年化收益率（Annualized Rate of Return）是一个投资收益的度量指标，表示如果投资收益保持相同的速率，在一年的时间里预期的投资回报率。年化收益率将不同时间长度的投资收益进行标准化处理，便于投资者比较不同投资产品的收益率。它是一种投资收益的估算方式。这是我们计划中的加速器。 通货膨胀率通货膨胀率（Inflation Rate），是衡量货币购买力下降速度的指标，反映一定时期内物价水平的上涨幅度。通货膨胀会影响投资收益和生活成本，因此在计算实际收益和制定财务规划时需要考虑通货膨胀率。通货膨胀率会随着政策、经济环境和市场情况而波动。这是我们计划中的不稳定的因素。下面是中国历年的统计数据： 一个例子通过上面的公式，我们来设想一个人退休所需要的本金。如果一个人的年度总支出为 20w，年度的被动总收入为 10w，我们无法掌握的参数为通货膨胀率，这里我们设定为 5%。他资产的年化收益率设置成 6% 到 10% 的区间。所需的本金如下： 年度总支出 - 年度总被动收入 年化收益率 - 通货膨胀率 退休本金 10w 0.01 392w 10w 0.02 314w 10w 0.03 257w 10w 0.04 214w 10w 0.05 182w 如果年度总支出为 30w，被动总收入为 10w 不变，则需要： 年度总支出 - 年度总被动收入 年化收益率 - 通货膨胀率 退休本金 20w 0.01 783w 20w 0.02 628w 20w 0.03 515w 20w 0.04 429w 20w 0.05 365w 每个人根据自己的情况，可以根据这个简化的公式来估算自己需要多少本金达到退休。钱挣不完，钱也花不完。做好计划，尽早地从挣钱中抽身，去做自己想做的事。 这是一份需要认真对待的计划，有以下一些参考注意的点： 对于年度总开支，要学会做预算，钱你想要花在哪里。 要留意扩展被动收入，分配一些精力在其中。警惕劳动收入的稳定性，注意其受宏观环境的影响。 一旦开始退休，年化收益率不要过高地追求，计划的稳定性是重要的。但不要停止在积累本金的阶段做寻找高收益方法的努力。 做好了退休计划之后，接下来的首要任务就是退休本金的积累问题了。在这个过程中，会接触其它一些财务概念和问题，比如债务，现金流、净资产，如何实现资产增值，需不需购买保险等。这些有空的话，后面再说一说了。 最后，保持学习和成长。主动学习是对未知世界的探索，这个探索的过程是美妙而快乐的。","categories":[],"tags":[{"name":"investment","slug":"investment","permalink":"https://orechou.live/tags/investment/"}]},{"title":"投资季度总结（2023Q1）","slug":"investment/投资季度总结_2023Q1_","date":"2023-04-01T14:00:00.000Z","updated":"2023-04-01T07:17:39.060Z","comments":true,"path":"investment/投资季度总结_2023Q1_/","link":"","permalink":"https://orechou.live/investment/%E6%8A%95%E8%B5%84%E5%AD%A3%E5%BA%A6%E6%80%BB%E7%BB%93_2023Q1_/","excerpt":"","text":"投资？人投入社会生产获取到金钱收入后，都会接触到投资、理财，不管是主动驱使还是朋友诱发，都会去想一个怎么用钱去生钱的问题。大部分人所参与到社会生产是充当劳动力的角色，依托于机构或公司，上班领取薪水。如果停止社会活动，或者经济环境变化，对个人的影响很大。所以扩展一些投资收入做一些财务管理是很必要的事情。本文中的投资指的是股票及衍生品的投资，而理财则是指对财产债务的管理。在格雷厄姆的著作《聪明的投资者》中说明，“投资就是以深入分析为基础，确保本金的安全，并获得适当的回报。 而投机则是完全试图从市场价格波动中牟利“。区分一个人是在投资还是投机很简单：1. 有无确保保证本金安全的意识和措施；2. 有无对所参与的市场活动有相应研究及行动的准则。投资者也分为两种，保守型和进取型。保守型的主要目的是保证资产不贬值，进取型的目的是在市场中获取更多的收益。关于鸡蛋要不要放在同一个篮子里面，这其实是一个风险控制的问题，对于入门者你不知道哪种投资市场适合你，那么将资金分散到不同的投资市场上是降低风险的方式。当你在市场中交够了学费，对于市场及其规则有了更多的了解，那么就可以多承担一些风险获取更高的收益。在参与投资、投机的前期，我将资金分成多份，分别参与到国内基金、A 股、港股、美股还有数字货币中。当时美其名曰资产配置，盲拍一个目标是跑赢通胀。但实际上无论是进入的时机，还是后续的操作都是不正确的，所以去年才基本回本。亏钱并没有助长我的赌徒心理，在交学费期间我是保守型的，不愿意将风险扩大。所以从 21 年到 22 年这两年基本是一个学习期，学习经典的书籍、学习别人的投资理念。期间看了很多书，比如入门的《穷爸爸，富爸爸》、《工薪族财务自由说明书》，经典的《聪明的投资者》、《证券分析》，技战术的《高胜率期权交易心法》，人物传记的 《股票作手回忆录》等。现在越来越确信的两点是：1. 财富是认知的变现；2. 不读书不可怕，只读一两本书很可怕。 对于我自己过往更多是投机的经历，我有以下三点总结： 做好储蓄，储蓄是投资的第一步。不要信什么钱不是省下来的鬼话。 评估自己，能承担的风险多大？投资的目标是什么？ 找到自己的能力圈，寻找到简单有效的投资策略，严格执行。 一个简单有效的策略一个简单有效的投资策略是：做看跌期权的卖方（Short put option）。接触到这个策略是一个很厉害的朋友教给我，大家有兴趣可以关注他的微信公众号：菠萝泵，今年他每周也在分享实盘。 看跌期权首先期权是一种金融衍生品，它赋予买方在一定时间内以某一特定价格购买或出售标的资产的权利；而对于期权的卖方来说，则有义务在买方行使期权时按约定的价格进行交易。期权通常涉及两个关键参数：行权价和到期日。行权价格是在期权到期时买方可以以该价格购买或出售标的资产的价格，而到期日则是期权的最后有效日。在期权交易中，买方支付给卖方一个权利金（也称为期权费用）以获得期权。如果在到期日，买方选择行使期权，卖方必须按照合同约定的价格交付标的资产或接收标的资产。如果买方选择不行使期权，卖方就可以保留所收到的权利金。文本的后续用股票来指代标的资产。用一个大家好理解的保险来解释这个内容。在股票市场中有许多持有股票的交易者，对于手上的股票的他们需要买一份保险来防止股票价格下降所造成的损失。然后有人能够提供这样一份保单：对于股票 A ，在保单的到期时间 B 时，可以将股票以 C 的价格卖给卖保单的人，这份保单的保费是 D 。这就是看跌期权的内容，其中 A 是标的资产，B 是到期日， C 是行权价， D 是权利金。做看跌期权的卖方，也就是做卖保险的人，收取保费 D。 TSLA 具体案例卖方赚取的是权利金，可能亏的是在被行权时，行权价和股票价差乘股数的金额。那么我们能赚多少钱，又有多大的概率亏钱呢？我们以特斯拉股票举例。TSLA 股票 3.31 日的收盘价格是 207 美元，一份到期日是 5 月 5 号、行权价是 145 美元的看跌期权，权利金是 108 美元（一份美式期权，在行权时对于 100 股）。 首先不管股票上涨还是下跌，期权到期我们赚到就是权力金 108 美元。那么我们看看到期发生的情况： 如果 TSLA 的股价大于 145 美元，没人会行权，因为没人会在这时把股票以 145 卖给你。 如果 TSLA 的股价小于 145 美元，假如是 140 美元。那么你将以 145 美元购入 100 股股票，那么接受股票亏的是 （145 -140） x 100 = 500 美元。如果 TSLA 跌到 0 ，接受股票的亏损达到了 （145 - 0）x 100 = 14500 美元。 看到这里，很多人可能会觉得才赚 108 美元，亏能亏到 1 万多美元。这是什么骗人鬼策略。这个时候要讲的内容是胜率。我们参与到市场交易活动中，每一笔交易盈利和亏损是一个概率游戏。而这个策略对卖方来说是一个高胜率的方法。从上面的例子直观来讲，TSLA 在一个月的时间，从 207 美元下跌 30% 到 145 有多大的概率，可能不高但还是可能。那么 TSLA 在一个月的时间，从 207 美元下跌 100% 直接归零有多大的概率呢？可能在某个平行时空才会发生吧 。我以 TSLA 举例是告诉大家明白这里可能会出现的亏损，警惕里面的风险点。但实际的市场交易中，我们可以选择那么股票价格没那么高，但权力金一样的股票标的。 高胜率原理我们来解释下为什么这个策略是高胜率的策略。首先期权的成交价格是买卖双方自由行为，但它也有一个定价模型来初始定价。即布莱克-斯科尔斯期权定价模型（B-S 模型），它有两个假设：1. 假定股票价格服从随机漫步（Random Walk），股票是呈正态分布的；2. 市场不存在套利机会，即市场价格合理。但这个假设是有问题的，股价的不是正态分布，而是大概率是偏态分布，优质公司的股价长期向上，而劣质公司的股价长期向下。二是未考虑到当前市场的一个整体估值和市场情绪。所以通过这个模型计算出来的期权价格的风险和收益是不对称的。那么对于那些优质股票，其期权的高收益不一定有高风险。我们可以调整标的股票、到期日和行权价来提高我们的胜率。另外一个事实是百分之 80 的期权最后都在到期日失效，没有行权。 止损措施对于这些存在的风险，也要设置好止损策略，当黑天鹅事件触发时不会犯错。 确定愿意承担的最大损失。可以是投资总额的一定比例，例如 10%。确保您设定的止损点不会导致超出此比例的损失。 设定触发止损的条件，这可以是期权价格上涨到达一定比例，如 50% 或 100% ，或者可以是股票价格上涨到达某一目标价位。 保持纪律，一旦设定了止损策略，请确保严格执行，避免因情绪波动而做出冲动的决策。 2023Q1今年我暂停了其他市场的交易活动，主要参与美股市场。在使用卖出看跌期权的策略上规定以下四点： 选择优质股，因为优质股票上期上涨。注意根据能力圈选股，不要选没有了解过的股票。 选择的行权价留有足够的安全边际（客观可以参考隐含波动率、Delta、股价等）。我的安全边际在 40% 以上，只有 BILI 因为之前经常持有其正股，所以对于 BILI 的安全边际设置较低。 2～8 周的期权时间价值快速衰减。主要做到期日在 1 到 2 月之间的期权，这样上个月卖出，直接等待下个月到期收取权利金。 注意仓位风险。我的保证金使用尽量控制在 50% 以下。 第一季度的收益情况：1月，盈利：8993，收益率：6.19%标的股票：PDD、BILI、COIN 2月，盈利：13377，收益率：8.67%标的股票：TQQQ、COIN、BILI、SOXL、FUTU 3月，盈利：12682，收益率：7.57%标的股票：TQQQ、COIN、BILI、SOXL、FUTU 整一季度收益率，简单加权：24.14%。初始保证金占用率：63%，维持保证金占用率：38%。 长长的破，厚厚的雪。2023 Q1 的盈利不多，但其实有两点值得说道：1. 不是浮盈，是现金流；2. 简单高效。接下来的下一个季度，保持投资策略不变，增加部分本金，加大保证金的比例。下一个季度总结再见吧。","categories":[],"tags":[{"name":"investment","slug":"investment","permalink":"https://orechou.live/tags/investment/"}]},{"title":"【Cyber Weekly】No.7 Kanata Haluka","slug":"weekly/No.7 Kanata Haluka","date":"2023-03-26T14:00:00.000Z","updated":"2023-03-26T13:33:54.492Z","comments":true,"path":"weekly/No.7 Kanata Haluka/","link":"","permalink":"https://orechou.live/weekly/No.7%20Kanata%20Haluka/","excerpt":"","text":"歌词：君の笑い方はなぜか優しさに似てた君の歌い方は今日の夕立に見えた何千年後の人類が何をしているかよりまだ誰も知らない顔で 笑う君を見たい僕にはない 僕にはないものでできてる君がこの僕を形作ってる枯れるほど君の名前叫んだら君に届くなら今叫ぶよ翻译：你的笑声仿佛温柔亲切你的歌声如今天的夕雨比起几千年后人类将做什么我更想看见你用一个仍未知晓的笑容我没有的东西，是你所拥有的你塑造着我的样子如果我高声呼喊你的名字到枯竭只要你能听到，我现在就会呼喊 Cyber Weekly 每篇的题目都用的写这篇周记期间对我产生影响的艺术作品的相关内容，目前有电影台词、游戏名称、诗歌、电影名称等。《Kanata Haluka》是《铃芽之旅》里面的一首歌，歌曲 Youtube 链接 Radwimps / カナタハルカ (Kanata Haluka)。 资源ChatGPT4 &amp; ChatGPT3 &amp; 文心一言心智成熟程度对比文心一言的理性思维能力距离GPT-4差多少？-虎嗅网这篇文章将 ChatGPT4、ChatGPT3.5 和文心一言的心智成熟程度做了对比，其挑选了认知科学家用来评定人类理性思维的四类经典测试任务：语义错觉类任务；认知反射类任务；证伪选择类任务；心智程序类任务。三者的正确率是，88%、58% 和 8%。而人类作答的正确率是：62%。即 GPT-4 实现了大跃迁，达到了一个超越人类的水准。 GraphQL 后端架构的经验分享GraphQL 后端架构的经验分享这篇博客是一位作者分享了他们使用 GraphQL 搭建后端的经验。作者总结了他们使用 GraphQL 的好处和建议，例如使用 GraphQL 需要仔细考虑数据模型和数据关系，避免查询性能问题，并建议开发人员使用 GraphQL 的工具和库，以提高开发效率。 Prompts 网站请稍候…ChatGPT、Midjourney、Stable Diffusion 等，直接复制 Prompts 就可以。 DNS 泄漏查询网站DNS leak test一个 DNS 泄漏的在线查询网站。 EVM PPTethereum_evm_illustrated.pdf图解以太坊 EVM，116 张 PPT 直接了解 EVM 的各种概念。 市场从本周的市场反应来看，银行危机这次黑天鹅事件已经基本结束了。另外值得一提的是这次币圈的上涨，如今比特币已经站稳了 27000，这次币圈的上涨也带动了我关注的两支相关股票（COIN &amp; MARA）的上涨。但本周 Coinbase 收到了美国证券交易委员会（SEC）的警告，面对可能来临的指控，COIN 在本周三股票跳水。对于 COIN 的 PUT，还有 30% 以上的安全边际，预留足够的安全边际是在市场里面生存的重要原则之一。 生活影视《铃芽之旅》铃芽之旅 (豆瓣)周六和老婆一起去看了这部电影。这是一部缅怀地震造成创伤的电影，讲述了铃芽的成长，还有和草太的爱情。电影大部分的画面与音乐都很一流，有日本的田野、乡村、海湾，京都的高楼林立，《Kanata Haluka》、《Suzume》和 《Tears of Suzume》三首歌都很棒。另外男主的外表总觉得很像《哈尔的移动城堡》的男主。故事的完整性比《天气之子》好，但整体比不上《你的名字》。故事结尾部分，长大的铃芽在往生里遇到了 4 岁时失去了妈妈的自己，让人心疼得落泪。那一刻是这部电影主题最好的表达，对生命不易的尊重，对伤痛的理解和同情，对未来的肯定。 家庭小宝宝的成长真的是一天一个样，这周 Aicko 已经可以四肢支撑了 😄，而且现在晚上睡觉正常也不用哄睡、吃夜奶了 🥳，更让人惊喜的是有时候发音可以听出 baba &amp; mama 😱。明天 27 号就 6 个月了，回想这半年、180 天真的很不容易，从呱呱坠地到现在呀呀学语，这个过程中所有的疲惫都可以忽略不计。在中国大部分的原生家庭或多或少都有些问题，我从小的成长环境让我的性格其实也有一些缺陷。我的另一半是一个明理、善良的人，从她怀孕到 Aicko 出生长大，这整个过程中我没有听到她一句抱怨的话。而且这段时间她反复跟我说要感恩，感恩婆婆、感恩小姨、感恩父母。是的，没有什么是应该的，对于现在我们应该感谢生命中遇到的每一个对我们付出善意的人，十分感谢🙏🏻。","categories":[],"tags":[{"name":"cyber weekly","slug":"cyber-weekly","permalink":"https://orechou.live/tags/cyber-weekly/"}]},{"title":"【Cyber Weekly】No.6 Suzume","slug":"weekly/No.6 Suzume","date":"2023-03-19T14:00:00.000Z","updated":"2023-03-19T13:39:08.185Z","comments":true,"path":"weekly/No.6 Suzume/","link":"","permalink":"https://orechou.live/weekly/No.6%20Suzume/","excerpt":"","text":"《Suzume》是新海诚的第 8 部电影，中文名是《铃芽之旅》，国内将在本月的 24 号引进上映。本周在 Apple Music 上一直循环该电影歌词（电影在日本去年年底已上映），仍旧是 RADWIMPS 乐队的词曲。自 16 年看完那部《Your Name.》后，新海诚的电影我都看了一遍、某些电影看过多遍，我喜欢电影里面那些很美的画面，也很喜欢搭配的电影配乐。这几年对日文歌曲有很大的偏爱，虽然我并不听得懂歌词，只听得出情绪。希望在我心未老去之前，去一趟日本感触一下电影里面的那些画面。 资源这一两个月 AIGI 和 ChatGPT 点爆了科技圈，这段时间关注的内容也跟这些相关。 AI 项目商业分析小报童上一个探索 AI 项目的内容，内容更新比较快，可以比较快速的了解已经在实践的一些项目。我订阅的目的是搜集一些 AI Idea。下面是一个分享订阅的链接。AI项目商业解析 awesome-ai-painting国内外 AI 绘画工具合集。不差钱的可以直接使用 midjourney。awesome-ai-painting: AI绘画资料合集 将 Siri 和 ChatGPT 搭配使用 iOS 快捷指令搭配 ChatGPT API。如何将 Siri 的生产力提高100倍 ChatGPT Plus本周开通了 ChatGPT Plus。使用 Depay 的虚拟信用卡，接受 USDT 的充值。我用币安直接出售了部分 ETH 直接转的。国内用户推荐使用欧易购买 USDT ，支持微信和支付宝，但是需要 T+7 很是蛋疼。现在 ChatGPT 除了我自己在用以外，今天也帮老婆搭配 Voice control 实现了英语外教。 市场通货膨胀 &amp; 银行危机美联储在过去的一年进行了多次加息，提高短期利率。加息可以通过减少借贷和消费支出来控制通货膨胀，这可能导致股票价格下跌。因为随着利率上升，企业和个人的贷款成本会增加，他们的消费和投资需求可能会减少。这会影响公司的盈利能力和市场情绪。另一方面，加息也可能会使美元走强。当美国的利率上升，国际投资者可能会更愿意购买美国的资产，以获得更高的回报。这会增加对美元的需求，从而推高美元汇率，增加美国的货币吸引力。上周 4 硅谷银行出现了流动性危机，在周 5 被加州监管机构关闭，其资产约为 2090 亿美元。成为美国史上第二大的银行倒闭案。在此事影响下，美股连续两日收跌。导致破产的直接原因是美联储持续加息导致债券投资账面浮亏，挤爆了投资端；货币紧缩导致企业不断取出存款补充现金流，挤爆了流动性；科技行业的退潮，科技行业存贷款业务萎缩；硅谷银行投资了很多长期债券，资产在高利率背景下出现大的浮亏，但在储户的挤兑下卖债券，使浮亏变成实亏。现在不管美联储是要治理通胀，还是要解决银行危机，市场的机遇都摆在眼前。这周我会关注以下美国债券的 ETF，如长期国债的 TLT 和短期国债的 GOVT、SHY。 生活妹妹酱马上要半岁了，本周集全家之力给妹妹拍了很多照片。现在变成了一个高冷的大宝宝，平时很难逗笑。这周的上班通勤巨累，下班的时候地铁人太多了，没有怎么看书。然后刷了一些 B 站视频，推荐两个：蝙蝠侠阿卡姆骑士彩蛋大合集、电影《信条》的解读。","categories":[],"tags":[{"name":"cyber weekly","slug":"cyber-weekly","permalink":"https://orechou.live/tags/cyber-weekly/"}]},{"title":"【Cyber Weekly】No.5 The Curious Case of Benjamin Button","slug":"weekly/No.5 The Curious Case of Benjamin Button","date":"2023-03-05T14:00:00.000Z","updated":"2023-03-05T12:57:01.471Z","comments":true,"path":"weekly/No.5 The Curious Case of Benjamin Button/","link":"","permalink":"https://orechou.live/weekly/No.5%20The%20Curious%20Case%20of%20Benjamin%20Button/","excerpt":"","text":"You could be mad as a mad dog at the way things went, you can swear and curse the fates, but when it comes to the end, you have to let go. 资源FilmGrab[FILMGRAB]免费电影截图网站，本期文章的截图即来自此网站。 PlanetScalePlanetScale: The world’s most advanced database platform数据库云服务。提供免费套餐，5GB 存储容量。 MailChimpMarketing, Automation &amp; Email Platform | Mailchimp邮件发送商。提供免费套餐，每月 1000 邮件发送。 AI 作画科普推文 / Twitter陈浩在 twitter 上做的 AI 作画的科普。 生活影视本杰明·巴顿奇事 The Curious Case of Benjamin Button豆瓣链接：本杰明·巴顿奇事 (豆瓣)读初高中那会儿是互联网未繁荣的时代，当时最大的兴趣爱好是看好莱坞电影，央视六台每周六晚的佳片有约是我当时接触到好电影的窗口。《本杰明巴顿奇事》第一次就是在那时看的，那时有点愤青，很喜欢电影里面的台词，“You could be mad as a mad dog at the way things went, you can swear and curse the fates, but when it comes to the end, you have to let go.” 但实际上，小屁孩其实什么都不懂，十几岁的小孩获得过什么、又失去过什么呢？昨晚和老婆又一起看了这部电影，这是第三次观影。这次我才注意到原来影片的开头有一个逆时钟表的故事，它是为了缅怀失去重要之物而制作的，希望时间能倒流、事情能挽回、已逝之人能回归。愿景是美好的，现实是冷酷的。钟表家并没有交代其后的故事，而古钟最后也被飓风来临的洪水淹没。本杰明的整个故事中，认真观影的人可以体会到多种情感、理解多样道理，生与死、原谅与救赎、爱和孤独，有没有勇气面对残酷的命运，有没有勇气放下一起重新开始。到故事的最后，本杰明变成婴儿死去。我有种和当时读完《百年孤独》和《月亮与六便士》的感觉：强烈的孤独和落寞感。即使人的一生再特殊，有过多少美好、幸福的经历，“But when it comes to the end, you have to let go”。现在我对快要 30 的自己说：“原谅自己的平凡，去生活、去热爱、去做自己。” 中国奇谭豆瓣链接：中国奇谭 (豆瓣)断断续续是看完了。印象比较深刻的几集，《小妖怪》、《鹅鹅鹅》还有《小满》。我是对中国古代志怪小说比较有兴趣的，希望第二季能够制作更多一些相关的故事。好的内容是基于一个好的故事的，改编不夹杂太多私货，出来的内容还是蛮优秀的。 阅读《高胜率期权交易心法》豆瓣链接：高胜率期权交易心法 (豆瓣)这本书第二次翻看。主要的思路是利用期权定价模型的不准确，利用风险的不对称性，高胜率地赚钱。主要的方式就是：Short put option，卖出看跌期权。本书中对于这个策略有以下的要点需要注意： 选择白马股（优质股），优质股票上期上涨。注意根据能力圈选股，不要选没有了解过的股票。 等待回调到近期低点。 选择的行权价留有足够的安全边际（可以参考隐含波动率、股价等） 2～8 周的期权时间价值快速衰减。 另外一个可以赚大钱但是胜率不高的策略是: Long call option，买入看涨期权。该策略有如下要点需要注意： 需要对公司乃至背后的行业有深入的研究，其中包括估值等。 选择长期看涨期权，6 个月起步，1 年或更长。用于应对短期的风险，预留足够长的时间做估值修复。（比如这次特斯拉大跌） 切记赌博心态。 其它的组合策略可以进阶之后使用利润来操作。复杂的策略除了应用条件比较苛刻以外，最大的问题是赚钱效果一般，因为其往往需要对股票的后市涨跌、幅度、时间做出比较准确的预测。预测的因素越多，存在偏差的可能性就越大。使用能赚钱的简单方法即可。目前使用 Short put option 的方法已实现 18% 的收益率，而且目前使用的保证金很少。后续等盈利更高之后，考虑总结一些目前的交易策略和实践经验。 其他Cyber weekly 原本是计划每周更新的，实践下来确实是没有那么多时间来完成。现在上下班通勤要 3 个小时，这几周也经常去医院，就抽空更新了。","categories":[],"tags":[{"name":"cyber weekly","slug":"cyber-weekly","permalink":"https://orechou.live/tags/cyber-weekly/"}]},{"title":"【读书】《卓有成效的工程师》","slug":"reading/卓有成效的工程师","date":"2023-02-18T11:30:00.000Z","updated":"2023-02-18T11:15:33.903Z","comments":true,"path":"reading/卓有成效的工程师/","link":"","permalink":"https://orechou.live/reading/%E5%8D%93%E6%9C%89%E6%88%90%E6%95%88%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%B8%88/","excerpt":"","text":"三句话总结本书 关注杠杆率（投资回报率） 关注代办事项，设置优先级四象限，重点是第一象限（重要、紧急）和第二象限（重要、不紧急）的事情 做一个高效率的工程师， 简单总结和感受这是一本面向程序员工程师的一本成长类的书籍，给出了成为一个高效率工程师或团队的方法论。对于个人来说，书中给出了一个杠杆率的可计算的指标，杠杆率 = 工作产生的影响 / 投入的时间，可以理解投资回报率。我们应该去做那些杠杆率高的事情。另外学习方式、任务优先级、投资迭代速度和想法验证等问题也是值得去关注的。不过后续的章节有些内容是交叉的，有些冗余。 读书笔记杠杆率高效工程师应时刻专注于做杠杆率（投资回报率）高的事情。 什么是杠杆率杠杆率 = 产生的影响 / 投入的时间可以理解成投资回报率（\u001dROI） 如何提高杠杆率 减少完成某项工作所需时间 ==&gt; 如何在更短的时间内完成工作? 增加该工作的产出 ==&gt; 如何增加该工作产生的价值？ 转向杠杆率更好的工作 ==&gt; 是否有其他工作可以在当下创造更多价值?我们在实际开展某项工作之前可以问自己上面三个问题，尝试提升该项工作的杠杆率。思考自己的杠杆点，优先做那些高杠杆率的事情。人总有一天会意识到时间才是自己自己最优先、最珍贵的资源。 学习方式培养成长型思维方式工程师是成长型的，我们要为自己能够改变的每一个方面负责，从提高谈话技巧到掌握新的工程重点都是自己能够掌控的内容。 提升学习的速率复利是一件强大的武器。做一件事最好的时间是 10 年前，其次是现在。明白学习复利的效益。虽然没有实际复利曲线那么夸张，但越早学习、优化学习方式（选择有挑战的事项）越能够获得更高的收益。 寻求好的工作环境选择工作或团队考虑以下影响因素： 公司或团队正在快速增长。（目前 Web3 就是这样的一共行业） 培训。 开放。鼓励提出问题；积极反馈和分享信息。 节奏。快速行动，但不会让人身心俱疲。 人员。身边有更聪明、更有才华、更有创造力的人。 自治。有自己的主导权和自由度。培养新的技能并持续学习每天花 20% 的时间在 Side Project 、专业领域或者相邻学科上。作为程序员工程师可以有如下的建议： 学习最优秀工程师写的核心抽象代码。努力编写代码，让最严格的人审核代码。 研读内部可获取的任何技术和学习资料，参加专业技能培训课程，学习自己不熟悉的代码，虚心请教。 掌握所使用的编程语言。（通过技术面试或者写技术文章来检验自己的掌握程度） 主动参加感兴趣项目的设计讨论。在不同类型的项目上工作，能够交叉练习不同的技能。 对于学习，有如下建议： 多阅读，加入讨论小组。能够将知识说出来是很有效的检验学习成果的方式。 参加讲座、行业会议或者线下聚会。 建立并维护一个强大的人际关系网。不要害怕或可以避免与不认识的人会面，走出自己的舒适圈，外面也并没有那么可怕。 关注那些传授技能的博客。 为教学写作。输出是最好的输入。 扩展兴趣项目。目的是提升自己的创造性。 培养健康的业余爱好。目的是提升自己的积极性。 优先级问题人的大脑是用来处理事情，而不善于存储的。对于一件件代办事项最好的事项是将其记录，而不是放在大脑中让其一直叨扰你的。如何记录代办事项参考 Get Things Done，对于任务的优先级划分使用任务紧急性四象限。 直接创建价值的工作功利一点，我们做的大部分事情的目的是为了获取价值。衡量这种价值的标准是交付的产品、获客率、业务指标的变化或销售业绩，即成果类的东西。对于一个程序员，工作时长、完成的任务、编写的代码行数或参与的会议数量，这样的事情是没有价值的。有一句话，代码是负债，产品是资产。 重要但不紧急的工作这部分工作是能够提升我们的能力，在未来能够创造更多的价值。 守护着日程把连贯的整块时间用来投入工作是效率很高的事情，我们能够进入一种心流的状态。学会拒绝不重要的事情，维护自己成块的时间。 限制同时进行的任务数把大脑类比成多核 CPU，找到自己的核心数。即重点是找到自己的能力同时处理的任务数量，不要超过这个限制，少了没有全力发挥，多了会影响每个任务的效果。 如果 xxx 就 xxx定义一些“如果xxx就xxx”的任务，来帮助你利用时间，完成那些遗漏、不想要去触碰的任务。例如：如果晚上 10 点找不到事情做，就刷一道 leetcode 题目。 时刻调整优先级工作的优先级会随时间变化，重新调整优先级是很重要的，另外不必给清单上所有的事情定好优先级。最重要的、且能够做到一个时间段只有那么几件。 投资迭代速度迅速行动，快速学习天下武功，唯快不破。 投资节省时间的工具如果某个任务必须手动做两次以上，那么第三次就去编写一个工具。工具是一个倍增器，它使我们能超越工作时间的限制，扩大自己的影响力。 缩短调试验证周期调试会占据研发工作中大部份时间，需要在前期做一些投资来缩短调试周期，而不是在每次迭代中支付时间税。建议如下： 提前规划好验证计划。 缩短调试验证的必要路径。 熟练掌握编程环境建议如下： 熟练使用自己最喜欢的文本编辑器或IDE。 至少学习一种高效的高级编程语言。 熟悉UNIX（或Windows）Shell命令。学习grep、sort、uniq、wc、awk、sed、xargs和find等基本命令，所有这些命令都可以通过管道连接来执行更高级的转换。 多用键盘，少用鼠标。 自动化手动工作流程。 在交互式解释器上测试新想法。 仅运行与当前变更相关的单元测试。 灵活使用 AI 工具。 工程以外的瓶颈对他人工作的依赖，在团队协作中协作方对任务的优先级错位。解决的方法是多沟通，同步信息。 记住有用的数字记住行业常见的数字，或者让自己能方便地获取这些数字，它们可以作为评估进度的基准，也可以帮助我们进行大概的推算。 质疑数据的完整性错误的数据会带来错误的决策，增强数据的完整性有如下几点： 广泛地记录日志以备用。 构建工具，在数据准确性上更快地迭代。 编写端到端集成测试以验证整个分析流程。 尽早检查收集的数据。 通过多种方式计算同一指标，交叉验证数据的准确性。 尽早分析有问题的数据。 尽早验证想法寻找验证工作成果的最低成本方法有以下几点启发点： 采用迭代的方式可以减少代价高昂的错误，并且在每次迭代之间，我们还有机会收集数据以纠正路线。迭代的周期越短，就能越快地从错误中吸取教训。相反，迭代的周期越长，不正确的假设和错误就越有可能混在一起，导致我们偏离正轨，浪费时间和精力。 做少量的工作来收集数据，以验证项目假设和目标，从长远来看，这会减少很多无谓的浪费。 先处理风险最大的领域，这样我们就能主动更新计划，避免出现讨厌的意外，这些意外可能会使我们之后的努力付诸东流。 一人团队的问题除非评审人在你的团队中工作，而且有共同的项目背景，否则在代码评审中很难获得有质量的反馈。如果你不注意建立反馈循环，那么很可能会推迟到自认为所做的工作已经近乎完美才会寻求他人的反馈。如果直到最后才发现走错了方向，就会浪费很多精力。当一个人负责的业务在推进的过程中，尽量提早向外反馈进度（比如这次的竞赛）下面是一些策略： 开诚布公，乐于接受反馈。改变防御性的心态，要优化我们的学习方式。不要把反馈和批评看作人身攻击，而要看作改进的机会。 尽早并经常提交代码进行评审。防止在设计上出现大的问题。另外大批量的代码也难于评审。不要害怕评审人的严厉。 先设计新系统的界面或 API，在开始编码之前先展示文档。 建立决策反馈机制项目估算谨慎对待项目重写重写可能会引入过度设计；增量和分阶段地重构项目是降低风险和增强灵活性的方式。 推荐书籍本书的结尾还推荐了一些书籍，做个记录后面有空再筛选出来看。 《人件》（Peopleware: Productive Projects and Teams） 《极客与团队：软件工程师的团队生存秘籍》（Team Geek: A Software Developer’s Guide to Working Well with Others） 《格鲁夫给经理人的第一课》（High Output Management） 《搞定：无压工作的艺术》（Getting Things Done: The Art of Stress-Free Productivity） 《每周工作4小时》（The 4-Hour Workweek: Escape 9-5，Live Anywhere，and Join the New Rich） 《高效能人士的七个习惯》（The 7 Habits of Highly Effective People: Powerful Lessons in Personal Change） 《清醒：如何用价值观创造价值》（Conscious Business: How to Build Value Through Values） 《高效能人士的思维方式》（Your Brain at Work: Strategies for Overcoming Distraction，Regaining Focus，and Working Smarter All Day Long） 《心流：最优体验心理学》（Flow: The Psychology of Optimal Experience） 《成功，动机与目标》（Succeed: How We Can Reach Our Goals） 书摘无书摘","categories":[],"tags":[{"name":"Reading","slug":"Reading","permalink":"https://orechou.live/tags/Reading/"}]},{"title":"Bcrypt 加密算法详解","slug":"java/Bcrypt 加密算法详解","date":"2023-02-12T10:00:00.000Z","updated":"2023-02-12T13:17:37.750Z","comments":true,"path":"java/Bcrypt 加密算法详解/","link":"","permalink":"https://orechou.live/java/Bcrypt%20%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"最近在回顾中台系统的用户权限设计，在用户密码落库这块使用了 Bcrypt 算法来保证安全性，这篇文章是对该算法的一个详细介绍。 什么是 Bcrypt 加密算法Bcrypt 是一种密码哈希函数，用于加密用户密码。它是一种强大且安全的算法，用于存储用户密码，并在用户登录时进行验证。Bcrypt 算法使用了 Blowfish 加密算法，它在对用户密码进行加密时需要一个随机的盐值，这样就可以避免暴力破解。此外，Bcrypt 算法还具有慢哈希的特性，即在加密过程中使用的复杂度可以通过 cost 参数来控制，从而使用户的密码更加安全。 加密的过程生成 Salt首先，Bcrypt 会生成一个随机的 salt，这个 salt 会被用于密码加密过程。 对密码和 salt 进行加密然后，密码和 salt 会被结合在一起，并使用密码哈希函数进行加密。 增加复杂度在加密的过程中，Bcrypt 会使用指定的 cost 参数进行加密，这个参数代表加密的次数。通过增加 cost 参数，可以使加密过程更加复杂，从而提高密码的安全性。 生成密文Bcrypt 加密后的密文是一个长度为 60~100 个字符的字符串。它包含了以下几部分信息： 版本标识：Bcrypt 的密文开头一般以 “$2y$” 或 “$2a$” 开头，这代表了 Bcrypt 的版本信息。 cost 参数：密文的下一个字符是数字，代表了 Bcrypt 加密过程中使用的 cost 参数。 salt：接下来的 22 个字符代表了随机生成的 salt。使用 Base64 编码。 哈希值：最后的字符串是加密后的哈希值，代表了密码的密文形式。使用 Base 64 编码。一个加密后的密文可能如下所示：&quot;$2a$10$S8U6dsEjvAUtf7XuUzK8.eDmI.xMh7OJj0s8Q7WuOvZDz9XBk1PM2&quot;。 与 SHA-256 算法的对比Bcrypt 和 SHA-256 都是常用的哈希算法，但它们的安全性是有所不同的。Bcrypt 有如下的优点： 慢哈希：Bcrypt 算法具有慢哈希的特点，即在加密过程中使用的计算复杂度可以通过 cost 参数来控制，从而使密码更加安全。而 SHA-256 并不具有这种特点，速度较快。 盐值：Bcrypt 在加密过程中使用了随机的盐值，这样就可以避免暴力破解。盐值存储在加密后的密文中，每个用户都有一个唯一的盐值。而 SHA-256 不支持使用盐值，因此它在数据库密码加密方面比 Bcrypt 更不安全 强度：Bcrypt 算法具有较高的强度，比 SHA-256 算法更难被破解。 由于 Bcrypt 算法具有以上特点，因此它可以有效防止数据库被拖库，并保证密码不被泄露。即使数据库被黑客获取，他们也无法获得用户的原始密码，因为密码已经被加密。因此，使用 Bcrypt 算法存储密码是一种安全的方法。 实际的应用Spring Security 就内置了 Bcrypt 算法的编码器 BcryptPasswordEncoder。 使用在项目中添加 org.springframework.security:spring-security-crypto 的依赖后在配置项中声明一个 Bean，代码如下： 1234@Beanpublic PasswordEncoder passwordEncoder() &#123; return new BcryptPasswordEncoder();&#125; 然后我们就可以在其他地方使用这个 PasswordEncoder 了，对应了两个方法 encode() 和 matches()。 实现源码其实现了 PasswordEncoder 接口，接口的定义如下： 1234public interface PasswordEncoder &#123; String encode(CharSequence rawPassword); boolean matches(CharSequence rawPassword, String encodedPassword);&#125; 编码的具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public String encode(CharSequence rawPassword) &#123; String salt; if (strength &gt; 0) &#123; if (random != null) &#123; salt = Bcrypt.gensalt(strength, random); &#125; else &#123; salt = Bcrypt.gensalt(strength); &#125; &#125; else &#123; salt = Bcrypt.gensalt(); &#125; return Bcrypt.hashpw(rawPassword.toString(), salt);&#125;public static String hashpw(String password, String salt) throws IllegalArgumentException &#123; Bcrypt B; String real_salt; byte passwordb[], saltb[], hashed[]; char minor = (char) 0; int rounds, off = 0; StringBuilder rs = new StringBuilder(); if (salt == null) &#123; throw new IllegalArgumentException(&quot;salt cannot be null&quot;); &#125; int saltLength = salt.length(); if (saltLength &lt; 28) &#123; throw new IllegalArgumentException(&quot;Invalid salt&quot;); &#125; if (salt.charAt(0) != &#x27;$&#x27; || salt.charAt(1) != &#x27;2&#x27;) &#123; throw new IllegalArgumentException(&quot;Invalid salt version&quot;); &#125; if (salt.charAt(2) == &#x27;$&#x27;) &#123; off = 3; &#125; else &#123; minor = salt.charAt(2); if (minor != &#x27;a&#x27; || salt.charAt(3) != &#x27;$&#x27;) &#123; throw new IllegalArgumentException(&quot;Invalid salt revision&quot;); &#125; off = 4; &#125; if (saltLength - off &lt; 25) &#123; throw new IllegalArgumentException(&quot;Invalid salt&quot;); &#125; // Extract number of rounds if (salt.charAt(off + 2) &gt; &#x27;$&#x27;) &#123; throw new IllegalArgumentException(&quot;Missing salt rounds&quot;); &#125; rounds = Integer.parseint(salt.substring(off, off + 2)); real_salt = salt.substring(off + 3, off + 25); try &#123; passwordb = (password + (minor &gt;= &#x27;a&#x27; ? &quot;00&quot; : &quot;&quot;)).getBytes(&quot;UTF-8&quot;); &#125; catch (UnsupportedEncodingException uee) &#123; throw new AssertionError(&quot;UTF-8 is not supported&quot;); &#125; saltb = decode_base64(real_salt, BCRYPT_SALT_LEN); B = new Bcrypt(); hashed = B.crypt_raw(passwordb, saltb, rounds); rs.append(&quot;$2&quot;); if (minor &gt;= &#x27;a&#x27;) &#123; rs.append(minor); &#125; rs.append(&quot;$&quot;); if (rounds &lt; 10) &#123; rs.append(&quot;0&quot;); &#125; rs.append(rounds); rs.append(&quot;$&quot;); encode_base64(saltb, saltb.length, rs); encode_base64(hashed, bf_crypt_ciphertext.length * 4 - 1, rs); return rs.toString();&#125; 验证密码的实现如下： 12345678910111213141516171819202122232425262728public Boolean matches(CharSequence rawPassword, String encodedPassword) &#123; if (encodedPassword == null || encodedPassword.length() == 0) &#123; logger.warn(&quot;Empty encoded password&quot;); return false; &#125; if (!BCRYPT_PATTERN.matcher(encodedPassword).matches()) &#123; logger.warn(&quot;Encoded password does not look like Bcrypt&quot;); return false; &#125; return Bcrypt.checkpw(rawPassword.toString(), encodedPassword);&#125;public static Boolean checkpw(String plaintext, String hashed) &#123; return equalsNoEarlyReturn(hashed, hashpw(plaintext, hashed));&#125;static Boolean equalsNoEarlyReturn(String a, String b) &#123; char[] caa = a.toCharArray(); char[] cab = b.toCharArray(); if (caa.length != cab.length) &#123; return false; &#125; byte ret = 0; for (int i = 0; i &lt; caa.length; i++) &#123; ret |= caa[i] ^ cab[i]; &#125; return ret == 0;&#125; 整个的代码是比较简单的，就不详细说明了。","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://orechou.live/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"https://orechou.live/tags/Java/"},{"name":"密码学","slug":"密码学","permalink":"https://orechou.live/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"关于 PriorityOrdered 和 Ordered 的使用","slug":"java/关于 PriorityOrdered 和 Ordered 的使用","date":"2023-02-09T15:00:00.000Z","updated":"2023-02-12T13:17:43.415Z","comments":true,"path":"java/关于 PriorityOrdered 和 Ordered 的使用/","link":"","permalink":"https://orechou.live/java/%E5%85%B3%E4%BA%8E%20PriorityOrdered%20%E5%92%8C%20Ordered%20%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"背景在调试某个 Springboot 项目业务代码的时候发现了一个现象：Bean 通过实现 Ordered 或 PriorityOrdered 接口来定义优先级，然后用 AnnotationAwareOrderComparator 对些 Bean 进行排序的时候，其顺序并没有按照 order 的大小进行排序。相关的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public class A implements PriorityOrdered &#123; @Override public int getOrder() &#123; return 0; &#125; &#125;public class B implements Ordered &#123; @Override public int getOrder() &#123; return -1; &#125;&#125;public class C implements Ordered &#123; @Override public int getOrder() &#123; return -2; &#125; &#125;public class Test &#123; public void sort() &#123; List&lt;Object&gt; list = new ArrayList(); list.add(new A()); list.add(new B()); list.add(new C()); // 排序的结果为: A-&gt;C-&gt;B，而不是第一反应认为的 C-&gt;B-&gt;A AnnotationAwareOrderComparator.sort(list); &#125; &#125; 原因跟一下源码可以很快查到原因，AnnotationAwareOrderComparator 是继承的 OrderComparator，而 OrderComparator 的比较是这样的： 12345678910111213141516171819@Override public int compare(@Nullable Object o1, @Nullable Object o2) &#123; return doCompare(o1, o2, null); &#125; private int doCompare(@Nullable Object o1, @Nullable Object o2, @Nullable OrderSourceProvider sourceProvider) &#123; // 当比较 PriorityOrdered 和 Ordered 的时候，默认 PriorityOrdered 的优先级是比 Ordered 高的，不会去看设置的 order 数值。 boolean p1 = (o1 instanceof PriorityOrdered); boolean p2 = (o2 instanceof PriorityOrdered); if (p1 &amp;&amp; !p2) &#123; return -1; &#125; else if (p2 &amp;&amp; !p1) &#123; return 1; &#125; int i1 = getOrder(o1, sourceProvider); int i2 = getOrder(o2, sourceProvider); return Integer.compare(i1, i2); &#125; 其实 Spring 的文档里面也说得很清楚： Extension of the Ordered interface, expressing a priority ordering: PriorityOrdered objects are always applied before plain Ordered objects regardless of their order values.When sorting a set of Ordered objects, PriorityOrdered objects and plain Ordered objects are effectively treated as two separate subsets, with the set of PriorityOrdered objects preceding the set of plain Ordered objects and with relative ordering applied within those subsets. 另外使用 ChatGPT ，它也可以很好的回答这个问题： 启发如果我们要让某个 Bean 具有最高优先级，可以通过给这个 Bean 设置 PriorityOrdered，而其它的 Bean 设置 Ordered。这样即使这个 Bean 的 order 数值很小，也不会被其他的 Bean 所影响。","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://orechou.live/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"https://orechou.live/tags/Java/"}]},{"title":"【Cyber Weekly】No.4 Do not go gentle into that good night","slug":"weekly/No.4 Do not go gentle into that good night","date":"2023-02-05T14:00:00.000Z","updated":"2023-02-05T09:51:27.000Z","comments":true,"path":"weekly/No.4 Do not go gentle into that good night/","link":"","permalink":"https://orechou.live/weekly/No.4%20Do%20not%20go%20gentle%20into%20that%20good%20night/","excerpt":"","text":"本周看了很多科幻影视剧，其实也就是《流浪地球2》和《三体》啦，所以本周的图片我将使用《星际穿越》的截图。[Doge]Do not go gentle into that good night. 资源开源项目归类网站Find Open Source该网站收录了 Github 上众多有价值的开源项目。可以按目录查找。 影子图书馆安娜的档案影子图书馆搜索引擎：书籍、论文、漫画、杂志。 包含：Z-Library、Library Genesis、Sci-Hub。 Big Ideas 2023ARK Invest | We Believe Innovation Is Key to Growth木头姐（Cathie Wood）的方舟投资公司（Ark Invest）发布了《Big Ideas 2023》年度投研报告，综述了全球最新的创新技术融合趋势，并覆盖了十三个创新领域的最新行业数据，分析及预测。 Web3.0创作者经济报告BlockBeats - 深度研究报告Web3.0创作者经济报告：CreatorFi的发展现状和想象空间 k8s_PaaSGitHub - ben1234560/k8s_PaaS: 如何基于K8s(Kubernetes)部署成PaaS/DevOps(一套完整的软件研发和部署平台)一个 k8s 的学习教程，一步步介绍如何部署成 PaaS/DevOps。 Damus推特创始人发布了基于 Nostr 的社交产品 Damus。去中心化，你将掌握自身数据，没人能够封禁你。我的公钥（身份地址）：npub1rfhhxz7n7ldu9wh8lc976ftjt0yrlan394mjr8ef4rmh789csucqteafdp 生活影视利刃出鞘2 Glass Onion: A Knives Out Mystery利刃出鞘2 (豆瓣)整个观影下来故事很易懂，故事剪辑的手法和故事讲述的顺序才让电视的时长达到了 2 个小时之久。不是很过瘾，演员的出场让我对电影的期待比较高，还有一些角色的出现让我没明白其中作用。比如岛上的陌生男子、码头上的《前目的地》男主。 流浪地球2流浪地球2 (豆瓣)除开电影里面的一些价值观输出，整个电影的剧情、结构还是很好的，整体比第一部好看很多。但 AI 的体现给人感觉没那么实际，或许是这一部份的逻辑体现不足。 阅读书籍：《从程序员到架构师》从程序员到架构师：大数据量 缓存、高并发、微服务 多团队协同等核心场景实战 (豆瓣)作者以自身的工作经历出发，结合实际的业务场景、技术背景来介绍了系统服务所遇到的问题，和相应的架构解决思路。有些点其实在工作中也能遇到，有相应体会。 书籍：《蛤蟆先生去看心理医生》蛤蟆先生去看心理医生 (豆瓣)恭喜蛤蟆先生找到了自我，走出了抑郁的阴影。有人会认为童年的不幸将会用一生来治愈，这种观念有点夸张，但童年对人影响巨大是毫无疑问的。我的成长中也经历了很多事情，让事情过去的方式，也只是让事情过去。我挺希望年轻时候能早点明白人格生成的原因，个人所处的心理状态，并知晓对应处理和转变观念的方式，或许能让自己心态没那么沉重。现在的生活也是考验，我希望我有“我好，你也好”的这种信念，让生活变美起来。 其他本周思想有了些变化，主要是意识到自己快 30 岁了，按照国内这样的内卷程度普通人 60 岁的时候可能就不行了。在深圳工作了 3 年，越发觉得留在这里得可能性越小，房价太高了。上上周的去看了师兄在坂田装修的新家，首付 150+、总价 500+ 的小三房，按照我们家现在的收入简直是要了老命。强行上车，往后的 30 年就是房子的奴隶，抵抗不了任何的风险，任何意外就是破产。一条明路是：轻松工作，体验生活，关爱家人。本周找出了毕业那会儿的 GoPro7 给家里小孩录录视频，另外下单了新的 m2 max 电脑，准备干点新事情。","categories":[],"tags":[{"name":"cyber weekly","slug":"cyber-weekly","permalink":"https://orechou.live/tags/cyber-weekly/"}]},{"title":"【效率】关于记录的工具及流程","slug":"other/关于记录的工具及流程","date":"2023-01-25T14:00:00.000Z","updated":"2023-01-25T15:10:01.000Z","comments":true,"path":"other/关于记录的工具及流程/","link":"","permalink":"https://orechou.live/other/%E5%85%B3%E4%BA%8E%E8%AE%B0%E5%BD%95%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%B5%81%E7%A8%8B/","excerpt":"","text":"一直以来我对知识的整理记录主要以摘录为主，久而久之发现其检索和提取的十分不方便，发展到最后就是很难坚持。所以我也有看一些关于写作、知识管理、工具推荐的书籍和文章。启发最大的两本书是《卡片笔记写作法》和《写作这回事：创作生涯回忆录》，前者让我学习到一种知识的收集整理方法，后者让我找到一种坚持写作记录的信念。算是找到了一套比较符合我自己的工具和流程。现总结如下，因为自身是 Apple 生态的用户，所以工具的选择主要是考虑到跨设备，其次再考虑跨平台。 知识管理知识管理：Obsidian + Dropbox 。Obsidian 是一个基于文件的 Markdown 编辑器，特点是支持笔记的双向链接，其次能够使用很多三方插件对软件自身的功能进行补齐。相比于 Notion ，Obsidian 最大的优点是数据存储在本地，在如今的互联网时代，自身对数据拥有绝对自主权是最大的优势。当然使用 Obsidian 也需要考虑多端同步的问题，使用云存储服务的免费方案是很好的选择，例如 Dropbox 的免费 1 GB 的容量，对于纯文本笔记已经绰绰有余了。当然对于图片的需求，可以搭建免费（Github）的图床或收费的 OSS 服务（云服务厂商）。使用 Obsidian 完成知识管理，形成第二大脑，把内容和思维在工具上外显，主要注意以下几点： 使用文件目录分类，这主要是保留我之前的记录习惯。 所有的输入在 Obsidian 中进行，目的是将思维过程外显。 内容积累内容积累：Drafts。Drafts 是一个便捷的文本记录工具，文本格式支持普通文本和 Markdown，设备支持 Mac、iPhone、iPad，甚至还有 iWatch 应用。使用 iCloud 同步的体验非常好。另外 iWatch 的录音转文本的功能，可以在很多非通用场景下做文字记录。使用 Drafts 主要是完成卡片笔记的第一步，材料的收集，在收集的过程中主要注意以下几点： 非摘录内容必须用自己的话转述，这样才能确保内容已理解。 摘录的内容必须注明出处，这样才能方便后续知识管理的整理和引用。 记录的内容必须打上 Tag，方便后续提取和归纳。 每周定期回顾 Inbox 的内容，整理到 Obsidian 之中。 日记日常记录：Notes。Notes 是 Apple 原生的备忘录软件。其实日记有一款叫 iDaily 的软件很好，其还有插入定位和天气的功能，但这款软件已经从买断制变成了订阅制，订阅的费用不菲。对于我来说就没什么必要了，我用 Notes 搭配 iCloud 记录一些生活上的日记，能够上传图片即可。","categories":[],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://orechou.live/tags/Tools/"},{"name":"Efficiency","slug":"Efficiency","permalink":"https://orechou.live/tags/Efficiency/"}]},{"title":"【Cyber Weekly】No.3 There and back again","slug":"weekly/No.3 There and back again","date":"2023-01-22T14:00:00.000Z","updated":"2023-01-23T14:10:40.000Z","comments":true,"path":"weekly/No.3 There and back again/","link":"","permalink":"https://orechou.live/weekly/No.3%20There%20and%20back%20again/","excerpt":"","text":"Cyber weekly 收录本人获取到的 Crypto、Backend &amp; Mobile 相关资讯、技术，另外夹杂一些生活记录。 有几周没有更新了，得了新冠之后恢复身体调整了比较久的时间，后面家里也有些事情就搁置了。现在春节前后也有点时间，就抽时间来续上。 Life读库本周买了一年的读库会员，京东上面的购买的话，除了今年的 6 本书以外，还有一年的读库 APP 会员，上面可以读往期的内容，还是比较划算。今年需要提升一下自己的阅读量，扩宽一下知识面。总的了解下来《读库》还是一个比较好的选择。上周一共看了两篇文章，一篇讲第九艺术的《暴风将至》和一篇互联网信息相关的《互联网是人类历史的一段歪路吗？》，后需整理一下相关的总结。 使用 n8n 聚合信息摄入和输出本周通过 n8n 使用自动工作流搭建了下信息摄入的聚合并输入到 telegram 的账号。参考了如下的两篇文章，使用自动化工作流聚合信息摄入和输出 | Reorx’s Forge ，使用 Railway 和 Supabase 零成本搭建 n8n 自动化平台 | Reorx’s Forge。除此之外，因为 twitter 的开发者账号能使用的 API 权限变更了，所以集成 twitter 进来还踩了一些坑。 除夕 &amp; 新年今年考虑到宝宝太小，今年没有回家去过年，待在深圳这边在岳父家过年了。算上来这也是第一次没有回家跟父母过春节，有些滋味是说不出来的。另外把家里一直隔离“小黑屋”的两小只放出来了，希望两小只能和女儿和平相处。 新年快乐。","categories":[],"tags":[{"name":"cyber weekly","slug":"cyber-weekly","permalink":"https://orechou.live/tags/cyber-weekly/"}]},{"title":"【生活】2023 年 OKR","slug":"life/2023 年 OKR","date":"2023-01-19T04:00:00.000Z","updated":"2023-01-23T14:11:09.000Z","comments":true,"path":"life/2023 年 OKR/","link":"","permalink":"https://orechou.live/life/2023%20%E5%B9%B4%20OKR/","excerpt":"","text":"今年的 OKR 如下，年底 review： 家庭okr1: 陪伴妻子和女儿成长 ，记录家人在一起、女儿成长的瞬间okr2: 定期给父母视频通话，频率由每月一次提高到每月两次okr3: 协助妻子确定其未来的职业方向okr4: 装修好在重庆的房子 个人成长okr1: 职业生涯更进一步，成为 senior engineer，扩展技术视野，入局 Web3okr2: 搭建知识管理系统，做好输入和输入，利用高效工具提升生产力okr3: 减少无意义的纯打发时间的娱乐，即使是游戏、电影，也争取做到有记录、有思考、有输出okr4: 维护个人博客、微信公众号、twitterokr5: 锻炼身体，增加体重（60kg）；锻炼与人沟通的能力 生活okr1: 旅游 3 次，每次 3 天以上，今年年底出入境放松的话去一趟日本okr2: 做好每日记录，文字记录，影像记录okr3: 应用软件数字移民，搭建 NAS 掌握私人数据 财务okr1: 美股年化收益率达 30%，不排除在 A 股、港股、数字货币市场寻找机会okr2: 控制家庭非必须消费，把钱用到刀刃上，做到能不消费的就不消费，必须消费的就消费最好的、长久的","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"https://orechou.live/tags/Life/"}]},{"title":"【Cyber Weekly】No.2 Red dead Redemption","slug":"weekly/No.2 Red dead Redemption","date":"2022-12-11T14:00:00.000Z","updated":"2022-12-12T02:00:06.000Z","comments":true,"path":"weekly/No.2 Red dead Redemption/","link":"","permalink":"https://orechou.live/weekly/No.2%20Red%20dead%20Redemption/","excerpt":"","text":"Cyber weekly 收录本人获取到的 Crypto、Backend &amp; Mobile 相关资讯、技术，另外夹杂一些生活碎嘴。“Cruel cruel world, must I go on? Cruel cruel world, I’m moving on.”本周事情较多。天气和疫情放开的原因，周末也没有出门，待在家里空了刷 RDR2 二周目。 Crypto# Web3 支付赛道全景式解读与趋势分析https://mp.weixin.qq.com/s?__biz=Mzg4MTU1MTE4NQ==&amp;mid=2247484501&amp;idx=1&amp;sn=16c9ed33fcb7a1558a848f4915791e6c&amp;chksm=cf65766bf812ff7d066285d03cf40a6f98055c14f44b8f361b83b6dac058069349d8c0c2b5fc#rd支付机构的基本面： 政策监管 商业模式（盈利方式：手续费、外汇、接入服务费、数字资产收益） 产品技术（包含：渠道层、支付网关、清结算系统 、通知模块、收银台） 全球出入金支付方式： 中心化交易所 独立出入金支付机构（Moonpay） 出入金聚合支付 加密货币零售终端（Bitcoin Depot） 场外出入金 加密货币支付解决方案 第三方支付机构先将加密货币通过出入金的方式换成法币，再进行支付。 直接用加密货币交易，用户和商家同事使用加密货币。 Web3 支付产品技术 Web3 支付行业赛道 Tether Launches Offshore Chinese Yuan（CNHT） on Tronhttps://twitter.com/Tether_to/status/1600148779721756672泰达在 Tron 上发行锚定离岸人民币（Offshore RMB，中国境外流通的人民币）的人民币稳定币。离岸人民币不受中国境内的货币政策限制，主要集中在香港、新加坡等城市流通。泰达发行的 CNHT 本质上和 USDT 无任何区别。CNHT 不需要真实的人民币保证金。泰达只保证了自己 USDT 的资产价值和自己发行的资产价值挂钩。其意义在于，深圳小电商，卖货到国外。外汇的话黑市很难，回款要快只能用 USDT。目前找现金境内对敲，风险高时间长，CNHT 可以离岸快速匹配对敲。 5 On-Chain Signals That We’ve Bottomedhttps://www.theblockbeats.info/news/327745 大链上信号表明Crypto市场已经触底，仅供参考，如下： DeF i 总收益率上升 ==&gt; 资本风险偏好增加 Curve pools 再平衡 ==&gt; 资本对USDT的担忧减小 合约维持资金负利率，价格却稳定 ==&gt; 多头在顽强抵抗 波动率水平正常化 ==&gt; 底部在形成 Smartmoney 稳定币持有量下降 ==&gt; 可能在抄底 BackendCPU 的制造和概念https://plantegg.github.io/2021/06/01/CPU的制造和概念/一篇介绍 CPU 基础相关知识的文章。 What is kubernetshttps://blog.bytebytego.com/p/ep35-what-is-kubernetesKubernets 的官网技术文档也详尽。不过最近在 newsletter 上订阅的 bytebytego 的文章，上面的一些文章配图清晰，文章简单容易理解，也是不错的。 LifeChatGPT本周注册了 ChatGPT ，慢慢尝试将他作为一个工作上的助手。 如何注册 地址：openai.com 挂日本全局梯子 SMS Activate 注册，使用印度号码激活。ChatGPT 为什么这么强。https://mp.weixin.qq.com/s/haaL-2XjRG0oS24pQyqw1AChatGPT 资源相关https://chrome.google.com/webstore/detail/chatgpt-for-google/jgjaeacdkonaoafenlfkkkmbaopkbilfChatGPT for Google，在使用 Chrome 使用谷歌搜索问题时，右侧会展示出 ChatGPT 的回答。https://github.com/f/awesome-chatgpt-prompts使用 ChatGPT 时的提示用例。 一份英语学习资源https://qwerty.kaiyi.cool/ 世界杯周末看了世界杯八强赛。巴西和克罗地亚点球大战时，巴西首罚球员一看就要丢，不明白为何首罚不安排内马尔。阿根廷和荷兰的点球大战时，首罚就是梅西。这种关键时刻肯定只能安排大赛选手的，排个不自信的上去踢不进士气打击太大了。有一说一，如果阿根廷 87 分不大脚开替补席，加时没那么长也许也不用踢点球了。不过很大原因还是这个裁判没能力，控场太差。我是希望两支南美球队在半决赛相遇，不要世界杯决赛变成欧洲杯。作为替补上场的 C 罗，听着就让人唏嘘。这次世界杯结束，梅西和 C 罗的世纪之争也结束了。作为一个观众，面对这种 4 年一次的大赛，看起来都觉得很珍贵（人生能有几个四年呢），更何况对于像梅西这样的球员呢？真心希望这次世界杯梅西不要有遗憾吧。","categories":[],"tags":[{"name":"cyber weekly","slug":"cyber-weekly","permalink":"https://orechou.live/tags/cyber-weekly/"}]},{"title":"【Cyber Weekly】No.1 The Shining","slug":"weekly/No.1 The Shining","date":"2022-12-04T14:00:00.000Z","updated":"2022-12-04T15:21:51.000Z","comments":true,"path":"weekly/No.1 The Shining/","link":"","permalink":"https://orechou.live/weekly/No.1%20The%20Shining/","excerpt":"","text":"Cyber weekly 收录本人获取到的 Crypto、Backend &amp; Mobile 相关资讯、技术，另外夹杂一些生活碎嘴。All work and no play makes Jack a dull boy.图摄于深圳高新园。上班，下班，是打工人的日常。 Crypto信任危机 - 中心化交易所透明度该何去何从https://tokeninsight.com/zh/research/market-analysis/trust-crisis-how-far-will-the-centralized-exchanges-transparency-go数据货币交易所的雷曼时刻。 2022年传统机构进入 Web3 里程碑https://twitter.com/0xjingle/status/1595327928543236096 中心化 Web3 - 你的小狐狸钱包还安全吗？https://tokeninsight.com/zh/research/market-analysis/unmasking-metamask-is-web3-really-decentralized-and-privateMetamask 在链上交互时使用的 Infura 的 RPC，Infura 是一个中心化的基础设施服务商，而 Infura 会收集用户的 IP 地址以及 ETH 钱包地址。 当我们在谈论去中心化身份（DID）时，我们在谈论什么https://mirror.xyz/0xF9e46113DDddB347259fcc2699283250Ac745303/MlMEFi_2dDqFH0vcISLNY2uSd9ZAnsbr_7FCSSbCFbw wtf.academyhttps://wtf.academy/learning-center一个 solidity 学习的网站，每个章节结束之后有练习可以做。 宏观经济网站http://currentmarketvaluation.com一个可以看宏观经济的网站，这个网站分别从收益率曲线、巴菲特指数、市盈率、利率、保证金债务、均值回归等6个角度看目前的市场在历史上所处的位置。 BackendTwitter Architecture 2022https://twitter.com/alexxubyte/status/1594008281340530688 CS 自学指南https://csdiy.wiki/收录了 CS 相关的课程视频，是比较好的课程资料。有时间重走学习的路线，比机械的背八股要好得多。我很反感背八股，可能因为我记忆力差，总是背不好吧。 Spring Boot 3.0 正式发布https://spring.io/blog/2022/11/24/spring-boot-3-0-goes-ga总结： 最低环境要求：Spring Boot 3.0 最低要求 Java 17 支持 GraalVM 原生镜像；支持具有 EE 9 baseline 的 Jakarta EE 10 提高应用可观察性：集成 Micrometer 支持具有 EE 9 baseline 的 Jakarta EE 10 依赖升级：Spring 框架 6.0+，第三方的技术依赖：https://github.com/spring-projects/spring-boot/releases/tag/v3.0.0Spring Boot 3.0 是第一个支持 Spring 6.0+ 和 GraalVM 的 Spring Boot 正式版本。 Life《巫师 3：狂猎》免费次世代更新内容公布据介绍，此次更新带来光线追踪、屏幕空间反射、植被强化等视觉改善内容，还为国内玩家带来了简体中文配音，并新增游戏视角和拍照模式等。《巫师 3：狂猎》次世代免费更新将于 12 月 14 日登陆 PC、PlayStation 5 和 Xbox Series S|X 平台。 快速将 iPhone 进入硬锁定状态同时按住手机电源和音量按钮，持续两秒，手机会有一个轻微的震动。屏幕上会出现三个选项：滑动关机、打给紧急联络人、取消。此刻手机已经进入「硬锁定」状态，即必须要密码才能解锁，指纹和面部识别都无法奏效。应该养成一个习惯，每当你要与手机分开、有一定人身风险的时候，要锁定我的 iPhone。 我的数据我做主：动手搭建一套自己的数据中心https://sspai.com/post/76919?utm_source=twitter&amp;utm_medium=social搭建这样一套数据中心需要有一定的技术背景。 手机博物馆https://www.mobilephonemuseum.com/这个网站收集了从 1980 年到如今的 2400 多款手机的照片和参数。","categories":[],"tags":[{"name":"cyber weekly","slug":"cyber-weekly","permalink":"https://orechou.live/tags/cyber-weekly/"}]},{"title":"【读书】《被讨厌的勇气：“自我启发之父”阿德勒的哲学课》","slug":"reading/被讨厌的勇气：“自我启发之父”阿德勒的哲学课","date":"2022-08-13T07:37:00.000Z","updated":"2023-02-18T11:15:06.935Z","comments":true,"path":"reading/被讨厌的勇气：“自我启发之父”阿德勒的哲学课/","link":"","permalink":"https://orechou.live/reading/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%EF%BC%9A%E2%80%9C%E8%87%AA%E6%88%91%E5%90%AF%E5%8F%91%E4%B9%8B%E7%88%B6%E2%80%9D%E9%98%BF%E5%BE%B7%E5%8B%92%E7%9A%84%E5%93%B2%E5%AD%A6%E8%AF%BE/","excerpt":"","text":"三句话总结本书 人生目的论。你现在所做所为，所经历、遭遇的一切都不是过去的原因造成的，而是受现在你的目的影响。（过去已经发生，你所能做的唯有改变自己的目的、心态） 课题分离（理清楚课题属于谁）、他者贡献（自己有贡献感即可，不需要关注别人的看法）。 将人生的聚光灯打在当下，过好此时此刻，不要特别在意过去（过去已经发生的无法改变）和未来（当下做的每一件事都影响着未来）。 简单总结和感受书的内容简单 &amp; 直观，以一个青年人与一个哲人的对话的形式展开。内容不多、章节很短，让人看着不累，我也许久没有完整看完过一本书了。更为主要的是最近工作 &amp; 生活压力比较大，外界噪音也比较多，很难有时间能够静下心来审视自己的内心。 最精华的3句书摘 ”即使你逃避人生课题、依赖人生谎言，那也不是因为你沾染了“恶”。这不是一个应该从道德方面来谴责的问题，它只是“勇气”的问题。“原谅自己、与自己和解：有些场合、有些事情、有些关系，我害怕去做、去拖延、去维护，心里有很大的负罪感、对自己失望，认为自己已经不行了。其实认清这是个勇气的问题，然后解决勇气的问题就好了，不要对自己失望很重要。 “有些男人会骂家庭主妇”又不挣钱！“或者”是谁养着你呀？“之类的话，也听到过有人说”钱随便你花，还有什么不满的呀？“之类的话，这都是多么无情的话呀！经济地位跟人的价值毫无关系。公司职员和家庭主妇只是劳动场所和任务不同，完全是”虽不同但平等“。”我已经成家立业，与妻子也即将迎来爱情的结晶。摘录这段问题是提醒自己不要变成这种讨厌、无情的人。 “跨出家门的那一瞬间，“旅行”已经开始，朝着目的地出发途中的每一个瞬间都是旅行。当然，即使因为某些事情而没能够到达金字塔，那也并非没有旅行。这就是现实性的人生。”我一直都在旅途中，希望自己把聚光灯打在当下，过好每一天、做好每一件事，别揪着过去不放，又一直对未来停留在幻想。","categories":[],"tags":[{"name":"Reading","slug":"Reading","permalink":"https://orechou.live/tags/Reading/"}]},{"title":"【生活】手机应用安装 & 使用指南","slug":"life/手机应用安装 & 使用指南","date":"2022-06-04T16:20:00.000Z","updated":"2022-06-05T07:48:04.000Z","comments":true,"path":"life/手机应用安装 & 使用指南/","link":"","permalink":"https://orechou.live/life/%E6%89%8B%E6%9C%BA%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%20&%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"如今的世界，手机已经属于出行、工作、娱乐、生活所必不可缺少的设备。各种应用软件，例如知乎、抖音、淘宝等占据了人生的大部分时间。我作为电子产品的重度用户，在每天与电子设备的接触过程中，不仅耗费了大量的时间、也让身体出现一些问题。鉴于此，我决定优化手机应用软件的安装、使用，将手机的娱乐属性剔除，降低一些无效时间的消耗。 原则No.1 卸载所有游戏我不认为能在手机上玩到真正的好游戏，花点钱买 PS5 、Switch 你会有更好的游戏体验。手机游戏的最大优势是能够在任何时候杀掉你的时间。 No.2 劲量使用国外的软件 &amp; 服务如果不想被封禁、被 404，劲量选用国外的软件 &amp; 服务，做一个数字移民。 No.3 软件 &amp; 服务如果能通过电脑访问，劲量减少手机版安装此条规则主要是针对一些非实时性知识软件，例如：知乎、B 站。我在手机上刷知乎和 B 站大部分是娱乐内容、碎片化的讯息，过了一遍大脑什么都不会留下。如果使用电脑，我才会是主动有目的性的去了解一些内容。 No.4 卸载长时间不用的软件，让手机简单长时间不用的软件大概率之后也不会使用，而且现在流量很便宜，先卸载也没用任何关系。 一些软件推荐阅读iBooks目前对于数字书籍，已经弃坑了 kindle 、微信读书等一众硬软件。目前使用 epub 格式电子书 + iBooks + iCloud，可以在 iPhone、iPad 和 mac 上无缝切换，同步阅读记录、进度。 金融投资Futubull雪球Binance","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"https://orechou.live/tags/Life/"}]},{"title":"自定义 Spring Security 鉴权","slug":"java/Java_自定义 Spring Security 鉴权","date":"2022-06-01T09:00:00.000Z","updated":"2023-02-12T13:18:01.380Z","comments":true,"path":"java/Java_自定义 Spring Security 鉴权/","link":"","permalink":"https://orechou.live/java/Java_%E8%87%AA%E5%AE%9A%E4%B9%89%20Spring%20Security%20%E9%89%B4%E6%9D%83/","excerpt":"","text":"背景当我们使用 Spring 技术栈搭建单体的系统或服务时，若系统涉及到登录鉴权等功能，一般会使用 SpringSecurity 搭配一个 RBAC 的权限模型，很容易实现一套 OAuth2 鉴权、授权的流程。随着业务扩展，单体的服务作为一个微服务并入一个大的系统之后。我们为保证其他业务能够调用该单体服务，但是又无法让其他系统来使用该服务已有鉴权，从而引入其他微服务都用基础的鉴权服务。根据业务场景的区分，当单体服务内部使用的时候走 SpringSecurity 的鉴权，单体服务外部调用的时候使用基础鉴权服务鉴权。 基础要根据不同的场景启用或绕过 SpringSecurity。我们可以首先想到能否通过 URL 来区分不同的场景，使用 HttpSecurity 的 permitAll() 和 authenticated() 来让不同路径的接口是否需要走鉴权。除此之外，可以去修改 SpringSecurity 的 Filter ，使用自定义 Filter 或者用动态代理对 Filter 进行增强。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Aspect@Component@Slf4jpublic class AuthorizationHeaderAspect &#123; /** * 基础鉴权服务 Feign 调用业务 */ @Autowired private OauthFeignBiz oauthFeignBiz; @Pointcut(&quot;execution(* org.springframework.security.oauth2.provider.authentication.OAuth2AuthenticationProcessingFilter.doFilter(..))&quot;) public void securityOauth2DoFilter() &#123; &#125; @Pointcut(&quot;execution(* org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(..))&quot;) public void securitySecurityInterceptor2DoFilter() &#123; &#125; @Around(&quot;securityOauth2DoFilter()&quot;) public void enhanceSecurityOauth2DoFilter(ProceedingJoinPoint joinPoint) throws Throwable &#123; Object[] args = joinPoint.getArgs(); if (args == null || args.length != 3 || !(args[0] instanceof HttpServletRequest &amp;&amp; args[1] instanceof javax.servlet.ServletResponse &amp;&amp; args[2] instanceof FilterChain)) &#123; joinPoint.proceed(); return; &#125; HttpServletRequest request = (HttpServletRequest) args[0]; String accessToken = request.getHeader(&quot;Authorization&quot;); if (StringUtils.isNotBlank(request.getParameter(&quot;sceneId&quot;)) &amp;&amp; StringUtils.isNotBlank(request.getParameter(&quot;sceneType&quot;))) &#123; // 这里我们可以根据业务场景确定走哪种鉴权方式 SecurityUtils.setBaseAuth(true); &#125; else &#123; SecurityUtils.setBaseAuth(false); &#125; if (SecurityUtils.isBaseAuth()) &#123; Response&lt;CheckTokenResponse&gt; checkTokenResponse = oauthFeignBiz.checkToken(accessToken); if (checkTokenResponse.getCode() == 0) &#123; SecurityUtils.setBaseAuth((true)); ((FilterChain) args[2]).doFilter((ServletRequest) args[0], (ServletResponse) args[1]); &#125; else &#123; throw new Exception(&quot;鉴权失败&quot;); &#125; &#125; else &#123; // 让原 Filter 的逻辑继续执行 joinPoint.proceed(); &#125; &#125; @Around(&quot;securitySecurityInterceptor2DoFilter()&quot;) public void enhanceSecuritySecurityInterceptor2DoFilter(ProceedingJoinPoint joinPoint) throws Throwable &#123; Object[] args = joinPoint.getArgs(); if (args == null || args.length != 3 || !(args[0] instanceof HttpServletRequest &amp;&amp; args[1] instanceof javax.servlet.ServletResponse &amp;&amp; args[2] instanceof FilterChain)) &#123; joinPoint.proceed(); return; &#125; if (!SecurityUtils.isBaseOauth()) &#123; joinPoint.proceed(); return; &#125; ((FilterChain) args[2]).doFilter((ServletRequest) args[0], (ServletResponse) args[1]); &#125;&#125;","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://orechou.live/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"https://orechou.live/tags/Java/"}]},{"title":"【资源】Batcave Resources 第一期","slug":"other/网络资源","date":"2022-05-13T15:40:00.000Z","updated":"2022-07-12T07:41:33.000Z","comments":true,"path":"other/网络资源/","link":"","permalink":"https://orechou.live/other/%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90/","excerpt":"","text":"下面记录一些平时收录的一些资源。 资源站[1]Z-Library: 全球最大的数字图书馆目前对于数字书籍，已经弃坑了 kindle 、微信读书等一众硬软件。目前使用 epub 格式电子书 + iBooks + iCloud，可以在 iPhone、iPad 和 mac 上无缝切换，同步阅读记录、进度。 小工具[1]Batman-Logo: 新蝙蝠侠 Logo 生成器 [2]earth.fm: 聆听世界的白噪音 [3]muselink: 极简数字名片，只为创作者 [4]imgg: 以图片的方式截取并分享万物，简单，美观且隐私安全 [5]ActivityWatch: 一款免费的自动追踪在你设备上使用时间的软件","categories":[],"tags":[{"name":"Other","slug":"Other","permalink":"https://orechou.live/tags/Other/"}]},{"title":"【歌曲】Deadman's Gun && That's The Way It Is","slug":"life/Deadman's Gun","date":"2022-04-27T16:25:00.000Z","updated":"2022-07-30T09:27:42.000Z","comments":true,"path":"life/Deadman's Gun/","link":"","permalink":"https://orechou.live/life/Deadman's%20Gun/","excerpt":"","text":"成长道路是比较痛苦的，从青年一路走过来，自己的棱角被磨圆，没有了以往的神气。往往在深夜的时候，想起曾经那些喜欢的英雄，都已过去，都已逝去。而我才后知后觉，忘了告别。 歌曲 Deadman’s Gun 的 YouTube 地址。歌词如下： 1234567891011121314151617181920212223242526272829303132333435363738394041Your hands uponA deadman&#x27;s gun, and you&#x27;reLookin&#x27; down the sightsYour heart is warmAnd the seams are torn, and they&#x27;veGiven you a reason to fightAnd you&#x27;re not gonna takeWhat they&#x27;ve got to giveAnd you&#x27;re not gonna let &#x27;em take your will to liveBecause they&#x27;ve taken enoughAnd you&#x27;ve given them all you can giveAnd luck won&#x27;t save them tonightThey&#x27;ve given you a reason to fightAnd all the storms you&#x27;ve been chasin&#x27;About to rain down tonightAnd all that pain you&#x27;ve been facin&#x27;About to come into the lightYour hands uponA deadman&#x27;s gun, and you&#x27;reLookin&#x27; down the sightsYour heart is warmAnd the seams are torn, and they&#x27;veGiven you a reason to fightAnd you&#x27;re not gonna takeWhat they&#x27;ve got to giveAnd you&#x27;re not gonna let &#x27;em take your will to liveBecause they&#x27;ve taken enoughAnd you&#x27;ve given them all you can giveAnd luck won&#x27;t save them tonightThey&#x27;ve given you a reason to fightAnd all the storms you&#x27;ve been chasin&#x27;About to rain down tonightAnd all that pain you&#x27;ve been facin&#x27;About to come into the light 歌曲 That’s The Way It Is 的 YouTube 地址。歌词如下： 1234567891011121314151617181920212223242526272829303132333435363738394041[Verse 1]The many miles we walkedThe many things we learnedThe building of a shrineOnly just to burnMay the wind be at your backGood fortune touch your handMay the cards lay out a straightAll from your command[Chorus]That&#x27;s the way it isThat’s the way it isThat&#x27;s the way it isThat&#x27;s the way it is[Verse 2]Blue heron leaves the northern skyTrusts the journey to new heightsWhat’s the meaning of the scarIf we don&#x27;t know how to healShould we ever be apartThen how does it feel[Chorus]That&#x27;s the way it isThat&#x27;s the way it isThat&#x27;s the way it isThat&#x27;s the way it is[Bridge]Shine light into darknessShine light into darkness[Chorus]That&#x27;s the way it isThat&#x27;s the way it is (So many miles to walk)That’s the way it is (So many things we’ve got to learn)That&#x27;s the way it is (Oh, that’s the way it is)That&#x27;s the way it is (Oh)That&#x27;s the way it is","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"https://orechou.live/tags/Life/"},{"name":"Song","slug":"Song","permalink":"https://orechou.live/tags/Song/"}]},{"title":"【生活】EDC 清单","slug":"life/EDC 清单","date":"2022-04-12T15:40:00.000Z","updated":"2022-05-29T09:32:45.000Z","comments":true,"path":"life/EDC 清单/","link":"","permalink":"https://orechou.live/life/EDC%20%E6%B8%85%E5%8D%95/","excerpt":"","text":"EDC means everyday carry，即是每日通勤携带的物件。之前看过一本书《只过必要生活》，里面有一个建议是将你每天会用到的物品都放到通勤背包中每天携带。这篇博文就是整理我如今每天必用、必带的物品。 数码物品No.1 MacBook Pro 13公司配发的 MacBook Pro (13-inch, 2020)，Intel i7，32G。用途：写代码，写博客。 No.2 iPhone13 Pro Max自用手机，128G。用途：社交，投资，资讯。 No.3 Apple Watch Series 6自用手表，44 毫米款。用途：看时间，记录数据。 非数码物品No.1 新秀丽背包","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"https://orechou.live/tags/Life/"}]},{"title":"使用 SwiftUI 在地图中绘制坐标轨迹","slug":"iOS/使用 SwiftUI 在地图中绘制坐标轨迹","date":"2022-03-27T09:43:00.000Z","updated":"2023-02-12T13:19:19.543Z","comments":true,"path":"iOS/使用 SwiftUI 在地图中绘制坐标轨迹/","link":"","permalink":"https://orechou.live/iOS/%E4%BD%BF%E7%94%A8%20SwiftUI%20%E5%9C%A8%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%BB%98%E5%88%B6%E5%9D%90%E6%A0%87%E8%BD%A8%E8%BF%B9/","excerpt":"","text":"一直有想做属于自己的 App 的想法，零零散散地有学习一些内容，现在决定开启一个记录学习过程的系列博文，以此来巩固自己所学到的 iOS 开发知识和激励自己把第一个 App 实现出来。脑海中一直有个做地图类应用的想法，本科做移动轨迹相关的毕业设计。此类应用主要包括地图（Map）、坐标点（Location）、绘制轨迹（Polyline）几个要素。这篇博文将会使用 SwiftUI 在地图上连接坐标点绘制出轨迹。GPS 坐标数据可以在 microsoft 上下载。效果如下：首先创建一个 SwiftUI 工程的项目，项目的文件组织如下：先定义坐标点的数据结构，代码如下： 12345678910import Foundationstruct Location: Hashable, Codable, Identifiable &#123; var id: Int // 经度 var longitude: Double // 纬度 var latitude: Double var isValid: Bool&#125; 坐标数据的 ViewModel，我们将从 location.json 中加载所有的坐标点，代码如下： 1234567891011121314151617181920212223242526272829import Foundationfinal class LocationViewModel: ObservableObject &#123; @Published var locations: [Location] = load(&quot;location.json&quot;) &#125;func load&lt;T: Decodable&gt;(_ fileName: String) -&gt; T &#123; // The data value type allows simple byte buffers to take on behavior of Foundation objects. let data: Data guard let file = Bundle.main.url(forResource: fileName, withExtension: nil) else &#123; fatalError(&quot;Couldn&#x27;t find \\(fileName) in main bundle.&quot;) &#125; do &#123; data = try Data(contentsOf: file) &#125; catch &#123; fatalError(&quot;Couldn&#x27;t load \\(fileName) from main bundle:\\n\\(error)&quot;) &#125; do &#123; let decoder = JSONDecoder() return try decoder.decode(T.self, from: data) &#125; catch &#123; fatalError(&quot;Couldn&#x27;t parse \\(fileName) as \\(T.self):\\n\\(error)&quot;) &#125;&#125; 接下来我们将利用 UIViewRepresentable 这个协议实现将 UIKit 的 UIView 集成到 SwiftUI 中使用。UIViewRepresentable 只包含四个方法。其中 makeUIView , updateUIView 用于创建和更新视图。makeCoordinator 创建协调器，用于通知其它 UI 与该 View 之间的变化更新。dismantleUIView 用于在移除 View 时做一些善后操作。四个方法在 UIViewRepresentable 生命周期中的调用顺序如下：我们的 MapView 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import SwiftUIimport MapKitstruct MapView: UIViewRepresentable &#123; private let locationViewModel = LocationViewModel() private let mapZoomEdgeInsets = UIEdgeInsets(top: 30.0, left: 30.0, bottom: 30.0, right: 30.0) func makeCoordinator() -&gt; MapViewCoordinator &#123; MapViewCoordinator(self) &#125; func makeUIView(context: Context) -&gt; MKMapView &#123; let mapView = MKMapView() mapView.showsUserLocation = true mapView.delegate = context.coordinator return mapView &#125; func updateUIView(_ uiView: MKMapView, context: UIViewRepresentableContext&lt;MapView&gt;) &#123; updateOverlays(from: uiView) &#125; private func updateOverlays(from mapView: MKMapView) &#123; mapView.removeOverlays(mapView.overlays) var coordinates = [CLLocationCoordinate2D]() for i in 0..&lt;locationViewModel.locations.count &#123; let location = locationViewModel.locations[i] coordinates.append(CLLocationCoordinate2D(latitude: location.latitude, longitude: location.longitude)) &#125; let polyline = MKPolyline(coordinates: coordinates, count: locationViewModel.locations.count) mapView.addOverlay(polyline) setMapZoomArea(map: mapView, polyline: polyline, edgeInsets: mapZoomEdgeInsets, animated: true) &#125; private func setMapZoomArea(map: MKMapView, polyline: MKPolyline, edgeInsets: UIEdgeInsets, animated: Bool = false) &#123; map.setVisibleMapRect(polyline.boundingMapRect, edgePadding: edgeInsets, animated: animated) &#125;&#125;struct MapView_Previews: PreviewProvider &#123; static var previews: some View &#123; MapView() &#125;&#125; 协调器 MayViewCoordinator 代码如下： 12345678910111213141516171819202122232425262728import Foundationimport MapKitfinal class MapViewCoordinator: NSObject, MKMapViewDelegate &#123; private let mapView: MapView init(_ control: MapView) &#123; self.mapView = control &#125; func mapView(_ mapView: MKMapView, didAdd views: [MKAnnotationView]) &#123; if let annotationView = views.first, let annotation = annotationView.annotation &#123; if annotation is MKUserLocation &#123; let region = MKCoordinateRegion(center: annotation.coordinate, latitudinalMeters: 1000, longitudinalMeters: 1000) mapView.setRegion(region, animated: true) &#125; &#125; &#125; func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&gt; MKOverlayRenderer &#123; let renderer = MKPolylineRenderer(overlay: overlay) // set the line properties such as color and width renderer.strokeColor = .blue renderer.lineWidth = 3.0 return renderer &#125;&#125; 参考链接https://www.fatbobman.com/posts/uikitInSwiftUI/https://medium.com/@mauvazquez/decoding-a-polyline-and-drawing-it-with-swiftui-mapkit-611952bd0ecb","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://orechou.live/tags/iOS/"},{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://orechou.live/tags/SwiftUI/"}]},{"title":"【生活】记事一则","slug":"life/记事一则","date":"2022-02-13T07:40:00.000Z","updated":"2022-05-13T15:52:31.000Z","comments":true,"path":"life/记事一则/","link":"","permalink":"https://orechou.live/life/%E8%AE%B0%E4%BA%8B%E4%B8%80%E5%88%99/","excerpt":"","text":"下午，yoyo 和两支小🐱虎在😴。我坐在客厅写一些文字，记录一下心情。 首先要说的是，年前我和 yoyo 在老家举办完了婚礼，虽然我们还没有领证，但终于我们也算是完成了去年最大、最重要的一个 OKR。现在 yoyo 也🤰🏻了，虽然这也是之前一直计划的事情，但当 ta 真的来了的事情，我内心除了惊喜 max，还是有些慌张的。这种慌张不能让 yoyo 看出来。年后没几天我跟 yoyo 就工作城市深圳了，这座城市是很忙碌、劳累的。所以这段时间，我也一直在考虑怎么让我们更加轻松一些。所以现在关注了本身工作之外的一些内容，例如 区块链、NFTs、美股等等，想要找到一些虽不能说完成跨越，但至少能让自己工作不那么累的事情。我也一直在考虑未来自由职业的道路，但无奈自己现在很缺乏自信和对自己的认同。 今年定了几个 OKR，努力去实现吧。另外我得放松体验生活。不管再多事情，生活是我们自己的。先不说这么多了，我得叫 yoyo 起来出去散步了。","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"https://orechou.live/tags/Life/"}]},{"title":"【MySQL】实现列表数据置顶","slug":"mysql/MySQL_实现列表数据置顶","date":"2021-08-16T06:46:00.000Z","updated":"2022-03-27T11:14:09.000Z","comments":true,"path":"mysql/MySQL_实现列表数据置顶/","link":"","permalink":"https://orechou.live/mysql/MySQL_%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BD%AE%E9%A1%B6/","excerpt":"","text":"有的列表获取的业务场景，需要根据一些条件将数据置顶。 例如有一张表有 id 和 name 两个字段。数据表如下。 id name 1 1_name 2 2_name 3 3_name 4 4_name 5 5_name 6 6_name 7 7_name 8 8_name 9 9_name 10 10_name 若需要将 id 为 5 和 7 的数据置顶，并且分页的 size 是 5 的话，我们的 SQL 可以这样写： 1234567SELECT * FROM goods ORDER BY CASE WHEN id = 5 THEN -10000 WHEN id = 7 THEN -9999 ELSE id ENDLIMIT 0, 5","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://orechou.live/tags/MySQL/"}]},{"title":"【MySQL】慢 SQL 分析","slug":"mysql/MySQL_慢 SQL 分析","date":"2021-08-10T04:30:00.000Z","updated":"2022-03-27T11:14:03.000Z","comments":true,"path":"mysql/MySQL_慢 SQL 分析/","link":"","permalink":"https://orechou.live/mysql/MySQL_%E6%85%A2%20SQL%20%E5%88%86%E6%9E%90/","excerpt":"","text":"慢查询日志分析设置慢查询可以通过修改命令设置： 设置开启：SET GLOBAL slow_query_log = 1; #默认未开启，开启会影响性能，mysql重启会失效 查看是否开启：SHOW VARIABLES LIKE ‘%slow_query_log%’; 设置阈值：SET GLOBAL long_query_time=3; 查看阈值：SHOW 【GLOBAL】 VARIABLES LIKE ‘long_query_time%’; #重连或新开一个会话才能看到修改值 也可以通过修改配置文件设置，配置文件 my.conf 会一直生效，在[mysqld]下配置： 12345[mysqld]slow_query_log = 1; #开启slow_query_log_file=/var/lib/mysql/atguigu-slow.log #慢日志地址，缺省文件名host_name-slow.loglong_query_time=3; #运行时间超过该值的SQL会被记录，默认值&gt;10log_output=FILE 获取慢 SQL 信息查看慢查询日志记录数：SHOW GLOBAL STATUS LIKE ‘%Slow_queries%’; 模拟语句：SELECT SLEEP(4); 查看慢查询日志： 12345678910$ cat /usr/local/var/mysql/OreChoudeMacBook-Pro-slow.log/usr/local/Cellar/mysql/8.0.25_1/bin/mysqld, Version: 8.0.25 (Homebrew). started with:Tcp port: 3306 Unix socket: /tmp/mysql.sockTime Id Command Argument# Time: 2021-08-10T06:29:53.513752Z# User@Host: root[root] @ localhost [127.0.0.1] Id: 11# Query_time: 4.003605 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 1use test;SET timestamp=1628576989;select sleep(4); 使用 mysqldumpslow 分析使用样例： mysqldumpslow -s r -t 10 /usr/local/var/mysql/OreChoudeMacBook-Pro-slow.log #得到返回记录集最多的10个SQL mysqldumpslow -s c -t 10 /usr/local/var/mysql/OreChoudeMacBook-Pro-slow.log #得到访问次数最多的10个SQL mysqldumpslow -s t -t 10 -g “LEFT JOIN” /usr/local/var/mysql/OreChoudeMacBook-Pro-slow.log #得到按照时间排序的前10条里面含有左连接的查询语句 mysqldumpslow -s r -t 10 /usr/local/var/mysql/OreChoudeMacBook-Pro-slow.log | more #结合| more使用，防止爆屏情况 Explain 分析Show Profile 分析Show Profile 能够获取比 Explain 更为详细的信息，能够分析当前会话中语句执行时的资源消耗，获取 SQL 在整个生命周期的时间。 开启 Profile12开启：set profiling = on;查看：SHOW VARIABLES LIKE &#x27;profiling%&#x27;; 开启后 MySQL 后台会保存最近 15 次的结果。 查看 Profile使用 SHOW PROFILES 可以查看最近的 15 次结果。 查看具体的 Profile通过 Query_ID 可以得到具体 SQL 从连接 - 服务 - 引擎 - 存储四层结构完整生命周期的耗时。 使用命令：SHOW PROFILE CPU, BLOCK IO FOR Query_ID 可用参数type: ALL #显示所有的开销信息 BLOCK IO #显示块IO相关开销 CONTEXT SWITCHES #上下文切换相关开销 CPU #显示CPU相关开销信息 IPC #显示发送和接收相关开销信息 MEMORY #显示内存相关开销信息 PAGE FAULTS #显示页面错误相关开销信息 SOURCE #显示和Source_function，Source_file，Source_line相关的开销信息 SWAPS #显示交换次数相关开销的信息 如果出现以下几个状态则 SQL 需要重点分析： converting HEAP to MyISAM #查询结果太大，内存不够用了，在往磁盘上搬 Creating tmp table #创建了临时表，回先把数据拷贝到临时表，用完后再删除临时表 Copying to tmp table on disk #把内存中临时表复制到磁盘，危险！！！ locked","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://orechou.live/tags/MySQL/"}]},{"title":"【MySQL】Explain","slug":"mysql/MySQL_Explain","date":"2021-08-06T09:00:00.000Z","updated":"2022-03-27T11:14:13.000Z","comments":true,"path":"mysql/MySQL_Explain/","link":"","permalink":"https://orechou.live/mysql/MySQL_Explain/","excerpt":"","text":"MySQL ExplainExplain 是 MySQL 自带的查询优化器。 使用 Explain + SQL 可查询出执行的相关信息，主要包含以下 10 个属性：id, select_type, table, type, possible_key, key, key_len, ref, row, filtered, Extra 数据库性能瓶颈，主要关注 CPU 和 IO。 id反映的是表的读取顺序，或者查询中 SELECT 的执行顺序。 小表永远驱动大表，三种情况：（1）id 相同，执行顺序是由上至下的（2）id 不同，如果是子查询，id 序号会递增，id 值越大优先级越高，越先被执行（3）id 存在相同的，也存在不同的，所有组中，id 越大越先执行，如果 id 相同的，从上往下顺序执行 select_type反映的是 MySQL 理解的查询类型，有几下几种： SIMPLE：简单的 SELECT 查询，查询中不包含子查询或 UNION PRIMARY：查询中若包含任何复杂的字部分，最外层查询标记为 PRIMARY SUBQUERY：SELECT 或 WHERE 列表中的子查询 DERIVED：在 FROM 列表中包含的子查询，MySQL 会递归执行这些子查询，把结果放在临时表里 UNION：若第二个 SELECT 出现在 UNION 后，则被标记为 UNION，若 UNION 包含在 FROM 字句的子查询中，外层 SELECT 将被标记为 DERIVED UNION RESULT：UNION 后的结果集 table反映的是数据从哪张表中读取出来。 例如 &lt;derived2&gt; 表示从 id 为 2 的临时表读取。 typetype 是访问类型排序，反映的是 SQL 的优化状态，有如下几种： system：从单表只查出一行记录（等于系统表），这是 const 类型的特例，一般不会出现 const：查询条件用到了常量，通过索引一次就找到，常在使用 primary key 或 unique 索引中出现 eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描 ref：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它可能会找到多个符合条件的行，与eq_ref的差别是eq_ref只匹配了一条记录 range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般是在where语句中出现了 between、&lt;、&gt;、in 等的查询 index：full Index scan，index 和 all 的区别为 index 类型只遍历索引树。这通常比 all 快，因为索引文件通常比数据文件小 all：全表扫描，如果查询数据量很大时，全表扫描效率是很低的 在 SQL 优化中至少做到 range 级别，最好能达到 ref 级别 possible_key &amp; key &amp; key_lenpossible_key 反映的是 MySQL 推测可能用到的索引，不一定被查询实际使用到。key 反映的是实际使用到的索引，若为 null 则是因为没有建索引或者索引失效。key_len 反映索引中使用的字节数，可计算计算查询中使用的索引的长度，越短越好。其显示的值为索引字段的最大可能长度，而非实际使用长度。 refref 反映的是哪些列或者常量被用于查找索引列上的值。 rowsrows 反映的根据表的统计信息和索引选用的情况，大致估算出来到找到所有记录所需要读取的行数。 filtered使用 explain extended 时会出现这个列，5.7 之后的版本默认就有这个字段。这个字段表示存储引擎返回的数据在 server 层过滤后，剩下多少满足查询的记录数量的比例，不是具体记录数。 ExtraExtra 反映的不适合在其他列显示，但是也很重要的信息，主要有以下几种： Using filesort：MySQL 中无法利用索引完成的排序，这时会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。 Using temporary：使用了临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。 Using index：MySQL 相应的 select 操作中使用了覆盖索引，避免了访问表的数据行，效率高。 Using where：MySQL 使用了 where 过滤。 Using join buffer：MySQL 使用了连接缓存。 Impossible where：where 子句的值为 false。 Distinct：优化 distinct 操作，在找到第一匹配的元组后即停止找同样值的动作。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://orechou.live/tags/MySQL/"}]},{"title":"Socket 入门","slug":"old/Socket-入门","date":"2018-09-27T13:08:52.000Z","updated":"2018-09-27T13:08:52.000Z","comments":true,"path":"old/Socket-入门/","link":"","permalink":"https://orechou.live/old/Socket-%E5%85%A5%E9%97%A8/","excerpt":"Socket 英文有插座的意思，可以想象端口就是插座上的口，端口不能被其他进程占用。想象 Socket 类似于操作某个 IP 地址上的某个端口以达到点对点通信的目的，需要绑定到某个具体的进程和端口。 Socket 原本代表的是 Unix 上的原始套接字（RawSocket）用于描述文件的内存镜像，但因为 Unix 的设计哲学是“一切都是文件”，所以后来的网络版的进程间通信也就被冠名为文件描述符。本质上讲 Socket 是 Unix 系统设计的一种思想。 Socket 没有层的概念，可以把它看成是对 TCP/IP 协议簇的一个门面模式的封装。可以让编程变得更加简单。","text":"Socket 英文有插座的意思，可以想象端口就是插座上的口，端口不能被其他进程占用。想象 Socket 类似于操作某个 IP 地址上的某个端口以达到点对点通信的目的，需要绑定到某个具体的进程和端口。 Socket 原本代表的是 Unix 上的原始套接字（RawSocket）用于描述文件的内存镜像，但因为 Unix 的设计哲学是“一切都是文件”，所以后来的网络版的进程间通信也就被冠名为文件描述符。本质上讲 Socket 是 Unix 系统设计的一种思想。 Socket 没有层的概念，可以把它看成是对 TCP/IP 协议簇的一个门面模式的封装。可以让编程变得更加简单。 基础文件描述符文件描述符在形式上是一个非负整数。实际上，它是一个索引值，操作系统为每个运行的进程维护一张单独的文件描述符表。当程序打开一个现有文件或者创建一个新文件时，系统把一个指向此该文件内部数据结构的指针写入文件描述符表，并把该表的索引值返回给调用者 。应用程序只需记住这个描述符，并在以后操作该文件时使用它。操作系统把该描述符作为索引，用来访问进程描述符表，通过指针找到保存该文件所有的信息的数据结构。 系统创建一个 socket 连接，也是会打开一个 Socket 文件描述符。 函数Socket 通信双方的函数如下： socket1int socket(int domain, int type, int protocol); socket() 函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而 socket() 用于创建一个 socket 描述符（socket descriptor），它唯一标识一个socket。 打开一个网络通讯端口，如果成功的话，返回一个文件描述符，应用程序可以像读写文件一样用 read/write 在网络上收发数据，如果 socket() 调用出错则返回-1。 bind1int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen); 服务器需要调用 bind 绑定一个固定的网络地址和端口号。服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接。 bind() 的作用是将参数 sockfd 和 myaddr 绑定在一起，使 sockfd 这个用于网络通讯的文件描述符监听 myaddr 所描述的地址和端口号。 listen1int listen(int sockfd, int backlog);// backlog取值0~5. listen() 声明 sockfd 处于监听状态，并且最多允许有 backlog 个客户端处于连接待状态，如果接收到更多的连接请求就忽略。 listen() 成功返回 0，失败返回 -1。 accept1int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen); 三方握手完成后，服务器调用 accept() 接受连接，如果服务器调用 accept() 时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://orechou.live/categories/Linux/"},{"name":"Network","slug":"Linux/Network","permalink":"https://orechou.live/categories/Linux/Network/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://orechou.live/tags/Linux/"},{"name":"Network","slug":"Network","permalink":"https://orechou.live/tags/Network/"},{"name":"Socket","slug":"Socket","permalink":"https://orechou.live/tags/Socket/"}]},{"title":"Linux 命令","slug":"old/Linux-命令","date":"2018-09-27T12:33:48.000Z","updated":"2018-09-27T12:33:48.000Z","comments":true,"path":"old/Linux-命令/","link":"","permalink":"https://orechou.live/old/Linux-%E5%91%BD%E4%BB%A4/","excerpt":"Linux 命令时刻都会用到，除了 ls、cd、chmod 等，常用的可以分成两类，系统性能监控相关的命令和文本处理相关的命令。","text":"Linux 命令时刻都会用到，除了 ls、cd、chmod 等，常用的可以分成两类，系统性能监控相关的命令和文本处理相关的命令。 常用系统相关的命令： 命令 说明 top 能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器 ps 用于显示当前进程的状态。 iostat 对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。 free 显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。共享内存将被忽略。 vmstat 可对操作系统的虚拟内存、进程、CPU 活动进行监控。它是对系统的整体情况进行统计，不足之处是无法对某个进程进行深入分析。 lsof （list open files）列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。用于查看你进程开打的文件，打开文件的进程，进程打开的端口( TCP、UDP )。 netstat 显示与 IP、TCP、UDP 和 ICMP 协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 常用文件、文本处理相关的命令： 命令 说明 cat、more、less、head、tail 不用多说，查看文件。 find 在目录结构中搜索文件，并执行指定的操作。 grep 主要用于文本内容的查找，它支持正则表达式查找。 cut 可以按列来切分文件，可用于处理使用固定宽度字段的文件。 sed （stream editor）流编辑器，常用的用法是进行文本替换。 awk 可进行高级文本处理。通常由 3 个部分组成：BEGIN、END 和带模式匹配选项的公共语句块，但是三个部分都是可选的。awk 以逐行的形式处理文件。（1）首先执行 BEGIN 语句块中的语句；（2）接着从文件或 stdin 中读取一行，如果能改匹配 pattern，则执行随后的语句块中的语句。重复该过程直到数据读取结束。（3）当读到输入数据流的结束之后，执行 END 语句块。 which 查找某个命令的位置。 whereis 跟 which 类似，还能改打印出其对应的命令手册以及源代码的路径。 一些参数： -f：指定字符","categories":[{"name":"Linux","slug":"Linux","permalink":"https://orechou.live/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://orechou.live/tags/Linux/"}]},{"title":"Linux IO 原理","slug":"old/Linux-IO-原理","date":"2018-09-19T08:40:37.000Z","updated":"2018-09-19T08:40:37.000Z","comments":true,"path":"old/Linux-IO-原理/","link":"","permalink":"https://orechou.live/old/Linux-IO-%E5%8E%9F%E7%90%86/","excerpt":"在上一篇文章中主要介绍了 Java NIO 相关基础和 Reactor 模式，NIO 的实现在不同的平台上依赖于操作系统所提供的系统调用。下面将介绍 NIO 在 Linux 平台上的底层实现原理。","text":"在上一篇文章中主要介绍了 Java NIO 相关基础和 Reactor 模式，NIO 的实现在不同的平台上依赖于操作系统所提供的系统调用。下面将介绍 NIO 在 Linux 平台上的底层实现原理。 操作系统基础首先了解一下类 Unix 操作系统体系结构与基本概念。 类 Unix 的体系结构 操作系统内核（kernel）的本质是一个软件：可以控制计算机的硬件资源，并提供上层应用程序运行的环境。内核拥有可以访问受保护的空间和底层硬件设备的权限。 用户所编写的程序不能直接去访问内核代码，需要通过接口，这些接口被设计为系统调用（system call）。公用函数库建立在系统调用之上，应用程序即可以直接使用公用函数库，也可以使用系统调用。例如 fread 是 C 标准库函数，read 是系统调用。 Shell 是一个特殊的应用程序，为运行其他应用程序提供了一个接口。最外层的是应用程序。 用户态 &amp; 内核态类 Unix 的体系架构可以分为用户态和内核态。操作系统将虚拟空间划分成用户空间和内核空间两个部分，并划分了特权级，Intel x86 架构的 cpu 一共有 0～3 四个特权级，数字越小，特权越高，在 Unix/Linux 中指使用了 0 和 3 两个特权级，分别表示内核态和用户态。 用户应用程序一般在用户态下运行，当需要操作系统介入时，就会切换到用户态。用户态到内核态的切换方式： 系统调用：用户态进程主动通过系统调用申请操作系统提供的服务程序。（系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断） 异常：当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。 外设中断：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。 Linux 进程地址空间下图是 Linux 进程的内存地址空间，以 32 位的操作系统为例。 地址空间分成了两部分，用户空间（0x00000000 ~ 0xBFFFFFFF）和内核空间（0xC0000000 ~ 0xFFFFFFFF）。不同的进程用户空间是私有的。内核空间是持续存在的，并且是共享的，所有进程中都映射到同样的物理内存，内核代码和数据总是可寻址的，随时准备处理中断和系统调用。 用户空间的由如下的内容组成： Text Segmet（ELF，文本段）：程序代码在内存中的映射，存放二进制代码。 Data Segmet（初始化过的数据段）：存放程序运行时已经初始化赋值的静态变量数据（被程序员初始化）。 BSS Segment（未初始化的数据段）：存放程序运行时未被初始化的静态变量数据。 Heap：存储动态内存分配，需要程序员手工分配，手工释放。与数据结构中的堆是两回事，分配方式类似于链表。 栈：当有方法的调用的时候会产生一个方法栈帧进行压栈。栈帧中存储局部、临时变量，函数调用，存储函数的返回指针，用于控制函数的调用和返回。栈帧在函数程序块开始时自动分配内存，结束时自动释放内存。 数据读写Linux 的数据读写有两种方式，传统的读写与零拷贝技术。传统的读写数据需要复制两次，零拷贝技术只需要复制一次。下面以文件读写为例，简要说明一下传统的读写。 读数据 当应用程序需要读写磁盘上的数据时，会使用内核的系统调用。数据首先通过 DMA（Direct Memory Access）将磁盘上的数据复制到内核的缓冲区中，然后应用程序再从内核缓冲区中将数据复制到应用缓冲区。 写数据 当应用程序需要将数据传送给另外一个客户端时，也会使用内核的系统调用。应用程序首先将数据写入到内核的 socket 缓冲区中，然后再通过 DMA 将数据发给 socket 连接的另一端。 DMA copy。这是一种通过硬件实现的数据传输机制。简单的说，就是不在CPU的参与下完成数据的传输。 CPU copy 。 相比DMA而言，copy的过程需要用到cpu 寄存器等,速度较慢。 零拷贝技术考虑一个应用场景，服务器程序经常需要将一些数据通过网络传输给另外一个程序。 传统方式传统的处理方式是先将数据从磁盘上读出来，然后再将数据通过 socket 写出去。这会使用两个函数： 12File.read(fileDesc, buf, len);Socket.send(socket, buf, len); 流程图如下： 由图中我们可以看出数据一共被复制了 4 次： 磁盘复制到内核 Read Buffer Read Buffer 复制到用户空间 Buffer 用户空间 Buffer 复制到 Socket Buffer Socket Buffer 复制到 NIC Buffer 注：NIC（network interface card） 在整个过程中数据一共复制了 4 次，用户态-内核态切换了 4 次。Read 两次，Send 两次。 零拷贝零拷贝技术让整个数据复制的过程中不需要用户的参与，即数据传输直接在内核中完成，不需要复制到用户空间的缓存中。 12// out_fd: socket 或者 file 都可以用 fd 表示ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count); 流程图如下： 数据从磁盘复制到内核 Read Buffer 中后，直接复制到 Socket Buffer 中。 所以整个过程中数据只需要复制 3 次，用户态-内核态切换了两次。 Linux IO 模式对于一次 IO 访问（以 read 举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段： 等待数据准备 (Waiting for the data to be ready)，即数据复制到内核的缓冲区。 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)，内核缓冲区到用户空间的缓冲区。 linux 一共有下面五种 IO 模式： 阻塞 IO（blocking IO） 非阻塞 IO（nonblocking IO） IO 多路复用（ IO multiplexing） 信号驱动 IO（ signal driven IO） 异步 IO（asynchronous IO） 在实际的使用中，信号驱动 IO 并不常用。 文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 Unix、Linux这样的操作系统。 阻塞 IO（Blocking IO）在 Linux 中所有的 IO 默认都是阻塞模式，阻塞 IO 的流程如下： recvfrom 是从 socket 接受数据的系统调用。 1234ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags); 当使用这个系统调用的时候，内核会介入完成两部分操作： 准备数据，这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要时间的，不管是复制磁盘文件中的数据，还是接收 socket 传输的数据。而等待这一个过程，用户进程会将自己阻塞。 当内核中的缓冲区已经将数据复制好之后，就会将数据从内核中的缓冲区复制到用户空间中的缓冲区。复制完成之后返回结果，用户进程继续执行。 可以看到，用户进程在 IO 操作的两个阶段中都是被阻塞的。 非阻塞 IO（NonBlocking IO）非阻塞 IO 的流程如下： 在 Linux 中，可以通过以下三种方式将 IO 设置为非阻塞 IO： 123456789// 1.创建socket的时候，指定 socket 是异步的，在 type 的参数中设置 SOCK_NONBLOCK 标志即可。int socket(int domain, int type, int protocol);int s = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP);// 2.使用fcntl函数。fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);// 3.使用ioctl函数。1:非阻塞 0:阻塞。ioctl(sockfd, FIONBIO, 1); 非阻塞 IO 与阻塞 IO 的区别在于，在数据准备的阶段，用户进程不需要等待该阶段完成。用户进程会不断地去询问这个过程是否完成，若未完成用户进程也会收到一个回复，若已完成则开始第二阶段数据的复制。 多路复用 IO（IO Multiplexing）多路复用 IO 也被称为事件驱动 IO，流程如下： IO 多路复用通过 select、poll、epoll 实现。IO 多路复用优点在于单个 process 可以同时处理多个网络连接的IO。它的基本原理就是 select，poll，epoll 函数会不断的轮询所负责的所有连接的 socket，当某个 socket 有数据到达，就通知用户进程。 当用户调用了 select 后，用户进程需要等待 select 函数的返回，即有 socket 的数据就绪。在 Java 中的 Selector 提供了 select 方法和 selectNow 方法，前者需要等待有就绪的读写事件，而后者可以直接返回。 123456// allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become &quot;ready&quot; for some class of I/O operationint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);// wait for some event on a file descriptorint poll(struct pollfd *fds, nfds_t nfds, int timeout); 异步 IO（Asynchronous IO）异步 IO 是真正的异步非阻塞 IO，流程如下： 用户进程发起 read 操作之后，就立刻返回开始去做其它的事。而另一方面，从 kernel 的角度，当它受到一个asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 对比在 non-blocking IO 中，虽然进程大部分时间都不会被 block，但是它仍然要求进程去主动的 check，并且当数据准备完成以后，也需要进程主动的再次调用 recvfrom 来将数据拷贝到用户内存。而 asynchronous IO 则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。 多路复用的原理前面说到 Linux 实现多路复用是通过 select、poll、epoll 函数实现的。IO 多路复用是一种机制，这种机制提供了单个进程监听多个 IO 的能力。一个进程可以通过监听多个文件描述符，一旦某个描述符的某种事件就绪（读、写就绪），就通知程序进程读写操作。 selectselect 函数的定义如下： 12// allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become &quot;ready&quot; for some class of I/O operationint select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); select 关注了三种描述符，readfds、writefds、exceptfds，分别是读、写和发生异常的。可以通过设置 timeout 来指定等待事件，当将 timeout 设置为 null 时，select 会立即返回。函数返回值是就绪文件描述符的数量，0 表示timeout，-1 表示出错。函数返回后要通过遍历的方式找到就绪的fd。 select 采用的是轮询的方式监听所有的文件描述符，单个进程能够监听的文件描述符的数量有最大限制，在Unix下通常为256，Linux 下通常为1024，可以通过修改 /sys/types.h 头文件中的 FD_SETSIZE 值然后重新编译内核进行修改。 缺点： 可以监听的文件描述符有限。 以轮询的方式进行检查是否就绪效率低。 每次检查是否就绪要将所有需要被检查的 fd 的数据结构复制到内核，完成后修改这个数据结构并返回给程序，从用户空间到内核空间的来回拷贝将占用大量 CPU。 优点：在所有的平台上都支持 pollpoll 函数的定义如下： 12345678// wait for some event on a file descriptorint poll (struct pollfd *fds, unsigned int nfds, int timeout);struct pollfd &#123; int fd; /* file descriptor */ short events; /* requested events */ short revents; /* returned events */&#125;; poll 也是以轮询的方式进行监听，但与 select 不同的是 poll 抛弃了用位图存储文件描述符的方式，而使用 pollfd。需要监听什么事件，只需要初始化 events 即可，当 poll 函数返回时 revents 被设定为实际发生的事件。 缺点： 以论文的方式进行检查是否就绪效率低。 每次检查是否就绪要将所有需要被检查的 fd 的数据结构复制到内核，完成后修改这个数据结构并返回给程序，从用户空间到内核空间的来回拷贝将占用大量 CPU。 优点： 监听没有最大数量的限制。 select 的函数返回值是三个集合中就绪态的 fd 的数量之和，因此如果同一个 fd 在不止一个集合中同时被指定，且对于多个 I/O 事件都处于就绪态的话就会被统计多次，而 poll 的返回值是不重复的。 select 和 poll 都是需要通过遍历所有的文件描述符来获取已经就绪的事件，但是同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。 epollepoll 是在2.6内核中提出的，是之前的 select 和 poll 的增强版本。epoll更加灵活，没有描述符限制。epoll 使用一个文件描述符管理多个描述符，其他的文件描述符注册到这个描述符上，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。 epoll 有三个函数： 1234567891011// 创建一个 epoll 的句柄（实例），size 用来告诉内核这个监听的数目一共有多大int epoll_create(int size)；// 修改 epfd 所代表的 epoll 实例的兴趣列表，即可以向 epoll 实例添加、删除、修改 fd，并设定感兴趣的事件int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；// 返回 epoll 实例中处于就绪态的 fd 信息int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);struct epoll_event &#123; uint32_t events; /*指定了待检查的fd所感兴趣的事件集合，用位掩码表示*/ epoll_data_t data; /*用来在就绪后给调用进程传递信息*/&#125;; 步骤epoll_create调用该函数创建一个句柄（称为 epoll 句柄，epfd），指定的 size 用来告诉内核这个监听的数目的大小。size 不是限制 epoll 监听描述符的最大数量，而是内核对内存使用大小的一个建议。 epoll 句柄是一个文件描述符，它会占用一个 fd 值。在 Linux 中通过 /proc/pid/fd/ 可看到该值。所以在使用 epoll 的程序中，使用完之后应用 close 方法关闭 epoll，否则可能会导致 fd 被消耗殆尽。 epoll_ctl首先将一下函数中各个参数的意义： 参数 含义 epfd 调用 epoll_create 函数产生的 epoll 句柄 op 用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对 fd 的监听事件。 fd 监听的文件描述符 fd epoll_event 监听 fd 的事件 函数对指定的文件描述符 fd 执行指定的 op 操作。 event 集合如何： 123456EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；EPOLLOUT：表示对应的文件描述符可以写；EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；EPOLLERR：表示对应的文件描述符发生错误；EPOLLHUP：表示对应的文件描述符被挂断；EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 epoll_wait参数及意义如下： 参数 含义 epfd 调用 epoll_create 函数产生的 epoll 句柄 events 从内核得到的事件集合 maxevents 告诉内核这个 events 有多大，该值不能大于创建 epoll_create() 时的 size timeout 超时时间 该函数等待 epfd 上的 IO 事件。 工作模式epoll 对文件描述符的操作有两种模式：LT（level trigger）和 ET（edge trigger）。 参考资料[Linux IO模式及 select、poll、epoll详解]","categories":[{"name":"Linux","slug":"Linux","permalink":"https://orechou.live/categories/Linux/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://orechou.live/tags/Java/"},{"name":"Linux","slug":"Linux","permalink":"https://orechou.live/tags/Linux/"}]},{"title":"Java NIO","slug":"old/Java NIO","date":"2018-09-16T14:52:38.000Z","updated":"2018-09-16T14:52:38.000Z","comments":true,"path":"old/Java NIO/","link":"","permalink":"https://orechou.live/old/Java%20NIO/","excerpt":"Java IO 相关的文章，在网络上可以搜索到一大堆，并且 《Java NIO》和《Netty 权威指南》两本书可以包读者从入门到进阶。写这篇文章的目的在于让自己总结一下 Java IO 知识，从总结中学习。 Java 的 IO 大致可以分为如下几类： 磁盘操作：File 字节操作：InputStream &amp; OutputStream 字符操作：Reader &amp; Writer 网络操作：Socket 最开始 Java 只提供了 BIO（Block IO），Block IO 的意思是线程调用 IO 操作的时候，线程会阻塞等待 IO 完成。在这个期间，线程除了等待无法完成其他的事情。因为这种 IO 模式，之前的 Java 框架在编写服务器的时候，会对每一个 Socket 的请求新建一个线程进行处理。因为线程的新建与销毁是需要消耗系统资源的，所以若系统频繁地创建与销毁线程，那么会对系统资源造成很大的浪费。在这种 IO 模式下的改进方式是利用池化技术，通过线程池的方式来管理线程，减少线程频繁创建和销毁的开销。但是并没有改变最根本的问题，即一个服务请求的连接都需要一个线程来处理，在高并发的情况下，阻塞 IO 的实现肯定无法满足性能的需求。 针对这一问题，在 JDK 1.4 中 NIO 就登场了。","text":"Java IO 相关的文章，在网络上可以搜索到一大堆，并且 《Java NIO》和《Netty 权威指南》两本书可以包读者从入门到进阶。写这篇文章的目的在于让自己总结一下 Java IO 知识，从总结中学习。 Java 的 IO 大致可以分为如下几类： 磁盘操作：File 字节操作：InputStream &amp; OutputStream 字符操作：Reader &amp; Writer 网络操作：Socket 最开始 Java 只提供了 BIO（Block IO），Block IO 的意思是线程调用 IO 操作的时候，线程会阻塞等待 IO 完成。在这个期间，线程除了等待无法完成其他的事情。因为这种 IO 模式，之前的 Java 框架在编写服务器的时候，会对每一个 Socket 的请求新建一个线程进行处理。因为线程的新建与销毁是需要消耗系统资源的，所以若系统频繁地创建与销毁线程，那么会对系统资源造成很大的浪费。在这种 IO 模式下的改进方式是利用池化技术，通过线程池的方式来管理线程，减少线程频繁创建和销毁的开销。但是并没有改变最根本的问题，即一个服务请求的连接都需要一个线程来处理，在高并发的情况下，阻塞 IO 的实现肯定无法满足性能的需求。 针对这一问题，在 JDK 1.4 中 NIO 就登场了。 很多人将 NIO 称为 New IO 或者 Not Block IO，后者应该更贴切一点。 首先是 NIO 里面有哪些东西。 基本组件Buffer（缓冲区）NIO 处理的数据存储在 Buffer 里，一个 Buffer 对象是一个固定数量的数据容器，也可以视作数据传输的来源或者目标。 基本属性缓冲区的几个属性如下： Capacity（容量）：在创建时设定，无法在后续修改。表示能够容纳的数据元素的最大数量。 Limit（上界）：缓冲区中现存元素的计数，也表示了第一个不能读写的元素的位置。 Position（位置）：下一个要读或者要写的位置。 Mark（标记）：一个备忘的位置。 过程新建 Buffer假设创建一个容量为 10 的缓冲区。 12345ByteBuffer buffer = ByteBuffer.allocateDirect(10);// capacity: 10// limit: 10// position: 0// mark: x 填充 Buffer向缓冲区填充 5 次数据。 12345buffer.put((byte)&#x27;H&#x27;).put((byte)&#x27;e&#x27;).put((byte)&#x27;l&#x27;).put((byte)&#x27;l&#x27;).put((byte)&#x27;o&#x27;);// capacity: 10// limit: 10// position: 5 (即可视为当前 put 到数据中的数量，也可视为下个元素 put 的位置)// mark: x 翻转 Buffer当我们要去读取 Buffer 的时候，我们需要翻转（flip） Buffer。 123buffer.flip();// 代码等价于如下，即把 limit 位置设置成 position的位置，再将 position 设置为 0buffer.limit(buffer.position()).position(0); 压缩 Buffer当读取缓冲区中两个元素之后，缓冲区如下。 此刻从缓冲区中释放一部分数据，而不是全部，然后重新填充。为了实现这一点，未读的数据元素需要下移以使第一个元素索引为 0。从而将 Buffer 进行压缩（compact）。 1buffer.compact(); 根据图示，数据元素 2-5 被复制到 0-3 位置，4 以后的位置超出了 position，所以在后面 buffer 写入数据的时候被覆盖掉。 标记 Buffer使用标记函数将 mark 设置为当前 position 的值。当我们需要重复读取 Buffer 中某段数据的时候会可以派上用场。 1buffer.position(2).mark().position(4); 通道（Channel）通道位于缓冲区与通信的另一方（文件或 socket）之间，提供全双工的数据传输。JDK 1.4 提供的通道种类如下： FileChannel SocketChannel ServerSocketChannel DatagramChannel 打开 FileChannel 必须通过在 RandomAccessFile、FileInputStream 和 FileOutputStream 对象上调用 getChannel。而另外三个关于 socket 的通道则可以通过相应的静态工厂方法打开。原因在于，创建文件通道的时候，一定要有明确的文件目标，即先有了目标文件才去与之建立数据的通道。一个打开的文件通道对应了一个文件描述符。而开启 Socket 通道的时候还不知道谁来建立连接，与谁建立连接。 Socket 通道可以选择两种模式，阻塞模式和非阻塞模式。 12SocketChannel sc = SocketChannel.open( );sc.configureBlocking (false); // nonblocking NIO Socket 提供的非阻塞模式，是编写高性能 IO 应用的关键。对于 Java 编写的服务器来说，能够实现单线程对多个 Socket 连接的管理，并且方式简单。 选择器（Selector）通过将通道注册到选择器 Selector上，并绑定相关的事件，在后面就可以通过选择器找到这些通道就绪的相关事件。SelectionKey 封装了一个通道和选择器的注册关系。 123456789101112131415161718192021// step 1Selector selector = Selector.open();// step 2ServerSocketChannel ssChannel = ServerSocketChannel.open();ssChannel.configureBlocking(false); // 通道必须设置为非阻塞的模式ssChannel.register(selector, SelectionKey.OP_ACCEPT); // 这里注册了接受事件...// step 3// 当有就绪的通道的时候，我们可以调用 selectedKeys() 方法获取到这些 key，并进行处理int num = selector.select();Set&lt;SelectionKey&gt; keys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; // ... &#125; else if (key.isReadable()) &#123; // ... &#125; keyIterator.remove();&#125; 事件的种类如下： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 1234567public static final int OP_READ = 1 &lt;&lt; 0;public static final int OP_WRITE = 1 &lt;&lt; 2;public static final int OP_CONNECT = 1 &lt;&lt; 3;public static final int OP_ACCEPT = 1 &lt;&lt; 4;// 可以看出每个事件可以被当成一个位域，从而组成事件集整数int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; Selector 的原理图如下： Reactor 模式当使用 NIO 编写 Java 服务器相关的程序的时候，通常会采用名为 Reactor 的设计模式。 Wikipedia: The reactor design pattern is an event handling pattern for handling service requests delivered concurrently by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to associated request handlers. 画个图如下所示： 从图中可以看出当有外部事件发生后，这些事件发送给 Service Handler，Service Handler 的作用是做一个分发，将这些请求分发给具体的 Handler 进行处理。 那么将 Reactor 模式应用到 NIO 的服务器编程上，可以有三种方案。 单线程 Reactor Reactor 线程要做很多事情，包括： 接受请求，注册事件 将就绪事件分别处理 这种模式下，Reactor 线程又要维护连接，又要做相应的工作。 带线程池的 Reactor 单线程 Reactor 模式，最直观的改进方式就是在事件处理的部分引入工作队列 + 线程池。我们将就绪任务进行分类，对每一种类别的任务，提交到专属的线程池中去处理。这样 Reactor 线程只需要做接受请求，注册监听事件的任务。而任务的处理提交给其他线程，不仅可以减小 Reactor 的压力，也能够提高任务处理的速度。 主从多 Reactor 使用一个 Reactor 线程来接受请求，注册监听所有的读写事件，当读写事件变多时，但线程可能无法满足性能的需求。可以引入了多 Reactor，也即一个主 Reactor 负责监控所有的连接请求，多个子 Reactor 负责监控并处理读/写请求，减轻了主 Reactor 的压力，降低了主 Reactor 压力太大而造成的延迟。并且每个子 Reactor 分别属于一个独立的线程，每个成功连接后的 Channel 的所有操作由同一个线程处理。这样保证了同一请求的所有状态和上下文在同一个线程中，避免了不必要的上下文切换，同时也方便了监控请求响应状态。 总结Java NIO 的实现基于底层操作系统提供的相关 API，例如 Linux 提供了 select、poll、epoll 等系统调用。Java NIO 无疑为编写的 IO 程序提高了性能，但是其缺点在于实现复杂，维护和管理困难。这也是 Netty 框架致力于解决的缺点。","categories":[{"name":"Java","slug":"Java","permalink":"https://orechou.live/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://orechou.live/tags/Java/"}]},{"title":"Linux 命令基础","slug":"old/Linux 命令基础","date":"2018-09-15T07:19:41.000Z","updated":"2018-09-15T07:19:41.000Z","comments":true,"path":"old/Linux 命令基础/","link":"","permalink":"https://orechou.live/old/Linux%20%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80/","excerpt":"Linux 基础命令是任何一个开发人员应该掌握的基本技能。大多数项目的生产部署环境都会选择 Linux，所以在项目运维和故障排除的时候，Linux 命令能够起到关键的作用。","text":"Linux 基础命令是任何一个开发人员应该掌握的基本技能。大多数项目的生产部署环境都会选择 Linux，所以在项目运维和故障排除的时候，Linux 命令能够起到关键的作用。 获取文件内容基本指令 命令 描述 备注 cat 打印文件内容 -n: 打印出行号；-b: 不打印出行号 tac 是 cat 的反向操作，从最后一行开始打印 more 一页一页查看文件内容，比较适合大文件的查看 less 和 more 类似，但是多了一个向前翻页的功能 head 打印文件前几行 head -n filename tail head 的反向操作，打印后几行 od 以字符或者十六进制的形式显示二进制文件 指令 &amp; 文件搜索基本指令 命令 描述 备注 which 指令搜索 -a: 列出所有指令，而不是列出一个 whereis 文件搜索。速度非常快， 只搜索几个特定的目录 locate 文件搜索。可以用关键字或者正则表达式进行搜索 find 文件搜索。可以使用文件的属性和权限进行搜索 find 指令详解指令的基础用法如下： 12# find [basedir] [option] // basedir 不指定则为当前目录，及其子目录find . -name &quot;shadow*&quot; 按修改时间搜索的参数1234-mtime n ：列出在 n 天前的那一天修改过内容的文件-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件-newer file ： 列出比 file 更新的文件 按文件所属搜索的参数123456-uid n-gid n-user name-group name-nouser ：搜索拥有者不存在于 /etc/passwd 的文件-nogroup：搜索所属群组不存在于 /etc/group 的文件 按文件属性搜索的参数123456-name filename-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k-type TYPE-perm mode ：搜索权限等于 mode 的文件-perm -mode ：搜索权限包含 mode 的文件-perm /mode ：搜索权限包含任一 mode 的文件 正则表达式基本指令 指令 描述 备注 grep 使用正则表示式进行全局查找并打印 printf 用于格式化输出 在给 printf 传数据时需要使用 $( ) 形式 awk 每次处理一行，处理的最小单位是字段 grep 详解指令 grep （globally search a regular expression and print）的基本用法如下： 123456$ grep [-acinv] [--color=auto] 搜寻字符串 filename-c ： 统计个数-i ： 忽略大小写-n ： 输出行号-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行--color=auto ：找到的关键字加颜色显示 示例如下： 1234567# test.txt 的内容如下hello world123aaaaa$ gerp -n &#x27;world&#x27; test.txt1:hello world awk 详解指令 awk 的基本用法如下： 1$ awk &#x27;&#123;[pattern] action&#125;&#x27; &#123;filenames&#125; 每次处理输入流中的一行，然后根据设置的条件匹配相应的字段，然后做处理。 awk 变量： 变量名 代表意义 NF 每一行拥有的字段总数 NR 目前所处理的是第几行数据 FS 目前的分隔字符，默认是空格键 示例如下： 123456789101112131415# 取出登录用户的用户名和 IP$ last -n 5dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged indmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)# $1, $3 代表了第几个段，每行根据空格和tab来划分段$ last -n 5 | awk &#x27;&#123;print $1 &quot;\\t lines: &quot; NR &quot;\\t columns: &quot; NF&#125;&#x27;dmtsai lines: 1 columns: 10dmtsai lines: 2 columns: 10dmtsai lines: 3 columns: 10dmtsai lines: 4 columns: 10dmtsai lines: 5 columns: 9 Pipeline 指令管线指令 | 将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用 Pipeline。 下面的指令通常与管线指令搭配使用，将其它指令的输出作为指令的输入。 字符转换基本指令 指令 描述 备注 tr 删除一行中的字符，或者对字符进行替换 col 将 tab 字符转为空格字符 expand 将 tab 转换一定数量的空格，默认是 8 个 join 将有相同数据的那一行合并在一起 paste 直接将两行粘贴在一起 split 将一个文件划分成多个文件 cut 指令cut 对数据进行一行一行的切分，用法如下： 1234$ cut -d-d ：分隔符-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间-c ：以字符为单位取出区间 sort 指令sort 对数据进行排序，用法如下： 123456789$ sort [options] [file &amp; stdin] -f ：忽略大小写-b ：忽略最前面的空格-M ：以月份的名字来排序，例如 JAN，DEC-n ：使用数字-r ：反向排序-u ：相当于 unique，重复的内容只出现一次-t ：分隔符，默认为 tab-k ：指定排序的区间 uniq 指令uniq 只将重复的数据读取一次，用法如下： 123$ uniq [-ic]-i ：忽略大小写-c ：进行计数 tee 指令输出重定向会将输出内容重定向到文件中，而 tee 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。 进程管理基本指令 指令 描述 备注 ps 查看某个时间点的进程信息 -l: 查看自己的进程；-aux: 查看系统进程 top 实时显示进程信息 pstree 查看进程树 netstat 查看占用端口的进程 查看特定端口的进程：netstat -anp | grep port 进程状态在 Linux 中进程一共有 6 种状态，如下所示： 状态 说明 R running or runnable (on run queue) D uninterruptible sleep (usually I/O) S interruptible sleep (waiting for an event to complete) Z zombie (terminated but not reaped by its parent) T stopped (either by a job control signal or because it is being traced) X dead (should never be seen) 常用指令查看程序对应的进程号ps -ef|grep 进程名 查看进程占用的端口号netstat -anp|grep pid 查看端口号所对应的进程号lsof -i:端口号 数据流重定向重定向指的是使用文件代替标准输入、标准输出和标准错误输出。 描述 代码 运算符 标准输入 (stdin) 0 &lt; 或 &lt;&lt; 标准输出 (stdout) 1 &gt; 或 &gt;&gt; 标准错误输出 (stderr) 2 2&gt; 或 2&gt;&gt; 注意： 一个箭头的表示以覆盖的方式重定向，两个箭头的表示以追加的方式重定向。 可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。 如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出。例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。 指令搜索的顺序在类 Unix 操作系统中，按照如下的顺序搜索指令： 以绝对或相对路径来执行指令，例如：/bin/ls 或者 ./ls 由别名找到该指令来执行 由 Bash 内建的指令来执行 按 PATH 变量指定的搜索路径的顺序来找到指令来执行","categories":[{"name":"Linux","slug":"Linux","permalink":"https://orechou.live/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://orechou.live/tags/Linux/"}]},{"title":"JavaScript MVVM 双向绑定的实现","slug":"old/MVVM双向绑定的实现","date":"2018-06-20T14:02:15.000Z","updated":"2018-06-20T14:02:15.000Z","comments":true,"path":"old/MVVM双向绑定的实现/","link":"","permalink":"https://orechou.live/old/MVVM%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"这篇文章主要记录学习 JS 双向绑定过程中的一些概念与具体的实现 MVVM 具体概念MVVM 中有一些概念是通用的，具体如下 Directive （指令）自定义的执行函数，例如 Vue 中的 v-click、v-bind 等。这些函数封装了 DOM 的一些基本可复用函数API。","text":"这篇文章主要记录学习 JS 双向绑定过程中的一些概念与具体的实现 MVVM 具体概念MVVM 中有一些概念是通用的，具体如下 Directive （指令）自定义的执行函数，例如 Vue 中的 v-click、v-bind 等。这些函数封装了 DOM 的一些基本可复用函数API。 Filter （过滤器）用户希望对传入的初始数据进行处理，然后将处理结果交给 Directive 或者下一个 Filter。例如：v-bind=”time | formatTime”。formatTime 是将 time 转换成指定格式的 Filter 函数。 表达式类似前端普通的页面模板表达式，作用是控制页面内容安装具体的条件显示。例如：if…else 等 ViewModel传入的 Model 数据在内存中存放，提供一些基本的操作 API 给开发者，使其能够对数据进行读取与修改 双向绑定（数据变更检测）View 层的变化改变 Model：通过给元素添加 onchange 事件来触发对 Model 数据进行修改 Model 层的变化改变 View： 手动触发绑定 脏数据检测 对象劫持 Proxy 实现方式手动触发绑定即 Model 对象改变之后，需要显示的去触发 View 的更新 首先编写 HTML 页面 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Two way binding&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 这里定义了两个元素，input 元素用于接受用户输入，span 元素用于显示 --&gt; &lt;input q-value=&quot;value&quot; type=&quot;text&quot; id=&quot;input&quot;&gt; &lt;span q-text=&quot;value&quot; id=&quot;el&quot;&gt;&lt;/span&gt;&lt;/body&gt;&lt;script src=&quot;way_1.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 编写实现 MVVM 的 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Manual triggerlet elems = [document.getElementById(&#x27;el&#x27;), document.getElementById(&#x27;input&#x27;)]// 数据 Modellet data = &#123; value: &#x27;hello&#x27;&#125;// 定义 Directivelet directive = &#123; text: function(text) &#123; this.innerHTML = text &#125;, value: function(value) &#123; this.setAttribute(&#x27;value&#x27;, value) this.value = value &#125;&#125;// 扫描所有的元素function scan() &#123; // 扫描带指令的节点属性 for (let elem of elems) &#123; elem.directive = [] for (let attr of elem.attributes) &#123; if (attr.nodeName.indexOf(&#x27;q-&#x27;) &gt;= 0) &#123; directive[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]) elem.directive.push(attr.nodeName.slice(2)) &#125; &#125; &#125;&#125;// ViewModel 更新函数function ViewModelSet(key, value) &#123; // 修改数据对象后 data[key] = value // 手动地去触发 View 的修改 scan()&#125;// View 绑定监听elems[1].addEventListener(&#x27;keyup&#x27;, function(e) &#123; ViewModelSet(&#x27;value&#x27;, e.target.value)&#125;, false)// -------- 程序执行 -------scan()setTimeout(() =&gt; &#123; ViewModelSet(&#x27;value&#x27;, &#x27;hello world&#x27;)&#125;, 1000); 数据劫持数据劫持是目前比较广泛的方式，Vue 的双向绑定就是通过数据劫持实现。实现方式是通过 Object.defineProperty 和 Object.defineProperies 方法对 Model 对象的 get 和 set 函数进行监听。当有数据读取或赋值操作时，扫描（或者通知）对应的元素执行 Directive 函数，实现 View 的刷新。 HTML 的代码不变，js 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Hijackinglet elems = [document.getElementById(&#x27;el&#x27;), document.getElementById(&#x27;input&#x27;)]let data = &#123; value: &#x27;hello&#x27;&#125;// 定义 Directivelet directive = &#123; text: function(text) &#123; this.innerHTML = text &#125;, value: function(value) &#123; this.setAttribute(&#x27;value&#x27;, value) this.value = value &#125;&#125;// 定义对象属性设置劫持// obj: 指定的 Model 数据对象// propName: 指定的属性名称function defineGetAndSet(obj, propName) &#123; let bValue // 使用 Object.defineProperty 做数据劫持 Object.defineProperty(obj, propName, &#123; get: function() &#123; return bValue &#125;, set: function(value) &#123; bValue = value // 在 vue 中，这里不会去扫描所有的元素，而是通过订阅发布模式，通知那些订阅了该数据的 view 进行更新 scan() &#125;, enumerable: true, configurable: true &#125;)&#125;// View 绑定监听elems[1].addEventListener(&#x27;keyup&#x27;, function(e) &#123; data.value = e.target.value&#125;, false)// 扫描所有的元素function scan() &#123; // 扫描带指令的节点属性 for (let elem of elems) &#123; elem.directive = [] for (let attr of elem.attributes) &#123; if (attr.nodeName.indexOf(&#x27;q-&#x27;) &gt;= 0) &#123; directive[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]) elem.directive.push(attr.nodeName.slice(2)) &#125; &#125; &#125;&#125;// -------- 程序执行 -------scan()defineGetAndSet(data, &#x27;value&#x27;)setTimeout(() =&gt; &#123; // 这里为数据设置新值之后，在 set 方法中会去更新 view data.value = &#x27;Hello world&#x27;&#125;, 1000); 基于 Proxy 的实现Proxy 是 ES6 中的新特性。可以在已有的对象基础上定义一个新对象，并重新定义对象原型上的方法。例如 get 和 set 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Hijackinglet elems = [document.getElementById(&#x27;el&#x27;), document.getElementById(&#x27;input&#x27;)]// 定义 Directivelet directive = &#123; text: function(text) &#123; this.innerHTML = text &#125;, value: function(value) &#123; this.setAttribute(&#x27;value&#x27;, value) this.value = value &#125;&#125;// 设置对象的代理let data = new Proxy(&#123;&#125;, &#123; get: function(target, key, receiver) &#123; return target.value &#125;, set: function (target, key, value, receiver) &#123; target.value = value scan() return target.value &#125;&#125;)// View 绑定监听elems[1].addEventListener(&#x27;keyup&#x27;, function(e) &#123; data.value = e.target.value&#125;, false)// 扫描所有的元素function scan() &#123; // 扫描带指令的节点属性 for (let elem of elems) &#123; elem.directive = [] for (let attr of elem.attributes) &#123; if (attr.nodeName.indexOf(&#x27;q-&#x27;) &gt;= 0) &#123; directive[attr.nodeName.slice(2)].call(elem, data[attr.nodeValue]) elem.directive.push(attr.nodeName.slice(2)) &#125; &#125; &#125;&#125;// -------- 程序执行 -------data[&#x27;value&#x27;] = &#x27;Hello&#x27;scan()setTimeout(() =&gt; &#123; data.value = &#x27;Hello world&#x27;&#125;, 1000); 脏数据监测基本原理是在 Model 对象的属性值发生变化的时候找到与该属性值相关的所有元素，然后判断数据是否发生变化，若变化则更新 View。 编写页面代码如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Two way binding&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input q-event=&quot;value&quot; q-bind=&quot;value&quot; type=&quot;text&quot; id=&quot;input&quot;&gt; &lt;span q-event=&quot;text&quot; q-bind=&quot;value&quot; id=&quot;el&quot;&gt;&lt;/span&gt;&lt;/body&gt;&lt;script src=&quot;way_2.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; js 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Dirty detectionlet elems = [document.getElementById(&#x27;el&#x27;), document.getElementById(&#x27;input&#x27;)]let data = &#123; value: &#x27;hello&#x27;&#125;// 定义 Directivelet directive = &#123; text: function(text) &#123; this.innerHTML = text &#125;, value: function(value) &#123; this.setAttribute(&#x27;value&#x27;, value) this.value = value &#125;&#125;// 脏数据循环检测function digest(elems) &#123; for (let elem of elems) &#123; if (elem.directive === undefined) &#123; elem.directive = &#123;&#125; &#125; for (let attr of elem.attributes) &#123; if (attr.nodeName.indexOf(&#x27;q-event&#x27;) &gt;= 0) &#123; let dataKey = elem.getAttribute(&#x27;q-bind&#x27;) || undefined // 进行脏数据检测，如果数据改变，则重新执行命令 if (elem.directive[attr.nodeValue] !== data[dataKey]) &#123; directive[attr.nodeValue].call(elem, data[dataKey]) elem.directive[attr.nodeValue] = data[dataKey] &#125; &#125; &#125; &#125;&#125;// 数据监听function $digest(value) &#123; let list = document.querySelectorAll(&#x27;[q-bind=&#x27; + value + &#x27;]&#x27;) digest(list)&#125;// View 绑定监听elems[1].addEventListener(&#x27;keyup&#x27;, function(e) &#123; data.value = e.target.value $digest(e.target.getAttribute(&#x27;q-bind&#x27;))&#125;, false)// -------- 程序执行 -------$digest(&#x27;value&#x27;)setTimeout(() =&gt; &#123; data.value = &quot;Hello world&quot; $digest(&#x27;value&#x27;)&#125;, 1000); 总结上面只是简单地实现了双向绑定，但实际上一个完整的 MVVM 框架要考虑很多东西。在上面的实现中数据劫持的方法更新View 是使用了 Scan 函数，但实际的实现中（比如 Vue）是使用了发布订阅的模式。它只会去更新那些与该 Model 数据绑定的元素，而不会去扫描所有元素。而在脏数据检测中，它去找到了所有绑定的元素，然后判断数据是否发生变化，这种方式只有一定的性能开销的。 参考《现代前端技术解析》 代码下载","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://orechou.live/categories/JavaScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://orechou.live/tags/JS/"}]},{"title":"Java并发容器ConcurrentLinkedQueue源码解析","slug":"old/Java 并发容器ConcurrentLinkedQueue 源码解析","date":"2018-06-12T12:56:38.000Z","updated":"2018-06-12T12:56:38.000Z","comments":true,"path":"old/Java 并发容器ConcurrentLinkedQueue 源码解析/","link":"","permalink":"https://orechou.live/old/Java%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8ConcurrentLinkedQueue%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"Java提供了多种并发队列，具体如下： 无锁非阻塞队列：ConcurrentLinkedQueue &amp; ConcurrentLinkedDeque 普通阻塞队列：ArrayBlockingQueue &amp; LinkedBlockingQuene &amp; LinkedBlockingDeque","text":"Java提供了多种并发队列，具体如下： 无锁非阻塞队列：ConcurrentLinkedQueue &amp; ConcurrentLinkedDeque 普通阻塞队列：ArrayBlockingQueue &amp; LinkedBlockingQuene &amp; LinkedBlockingDeque 1、ConcurrentLinkedQueueConcurrentLinkedQueue和ConcurrentLinkedDeque是无锁非阻塞的，其实现方式是通过循环CAS（wait-free算法）。内部的数据结构是链表，都没有大小限制，容量是无限的。其 size() 遍历整个队列统计个数，不是一个O(1)时间的方法，并且返回的值不能准确的反应队列的实际大小。 源码分析head &amp; tail 节点head 和 tail 并不是一定指向整个队列的首部，和尾部。其满足一些规则：不变性和可变性。 123456789101112131415161718192021222324252627/** * A node from which the first live (non-deleted) node (if any) * can be reached in O(1) time. * Invariants（不变性）: * - all live nodes are reachable from head via succ() （所有的节点都可以通过 head 使用 succ() 方法取得） * - head != null （head 节点不为 null） * - (tmp = head).next != tmp || tmp != head （其实就是 head.next != head） * Non-invariants: * - head.item may or may not be null. （head 节点的值可能为null） * - it is permitted for tail to lag behind head, that is, for tail * to not be reachable from head! （允许 tail 滞后于 head, 也就是调用 succ() 方法, 从 head 不可达tail） */ private transient volatile Node&lt;E&gt; head; /** * A node from which the last node on list (that is, the unique * node with node.next == null) can be reached in O(1) time. * Invariants: * - the last node is always reachable from tail via succ() （tail 节点通过succ()方法一定到达队列中的最后一个节点(node.next = null)） * - tail != null * Non-invariants: * - tail.item may or may not be null. （tail 节点的值可能为null） * - it is permitted for tail to lag behind head, that is, for tail * to not be reachable from head! （允许 tail 滞后于 head, 也就是调用 succ() 方法, 从 head 不可达tail） * - tail.next may or may not be self-pointing to tail. （tail.next 可能指向 tail） */ private transient volatile Node&lt;E&gt; tail; 入队列offer元素入队的主要的工作： 将入队节点设置成当前队列尾节点的下一个节点 更新 tail 节点（tail节点不总是为队尾节点，减少了CAS更新 tail 节点的次数，提高入队效率）： 若 tail 节点的next节点不为空，则将入队节点设置成 tail 节点 若 tail 节点的next节点为空，则将入队节点设置成 tail 的next节点 123456789101112131415161718192021222324252627282930313233public boolean offer(E e) &#123; checkNotNull(e); // 根据传入的值构造节点 final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); // 通过 tail 节点找到队列的尾节点 for (Node&lt;E&gt; t = tail, p = t;;) &#123; Node&lt;E&gt; q = p.next; // 定位p为队列的尾节点 if (q == null) &#123; // 使用cas将新节点加入到队尾 // 比较p的next是否为null，为null才会设置成功。这里实现了同步，防止了别人已经修改了队尾，而设置了错误的位置 // if如果失败，则会循环再次执行 if (p.casNext(null, newNode)) &#123; // 插入成功之后，判断队尾节节点的前一个节点是否是tail节点，若不是，则将tail节点指向队尾节点 if (p != t) // hop two nodes at a time casTail(t, newNode); // Failure is OK. return true; &#125; // Lost CAS race to another thread; re-read next &#125; else if (p == q) // We have fallen off list. If tail is unchanged, it // will also be off-list, in which case we need to // jump to head, from which all live nodes are always // reachable. Else the new tail is a better bet. // 这里的情况是 p == p.next，并且t为tail节点。表示这个队列刚初始化，正在准备添加节点，所以返回head节点 p = (t != (t = tail)) ? t : head; else // Check for tail updates after two hops. // 重新赋值p结点，让p成为尾节点 p = (p != t &amp;&amp; t != (t = tail)) ? t : q; &#125;&#125; 出队poll元素出队的主要工作： 根据 head 节点找到队列首个不为空的节点，并CAS让该节点出队 更新 head 节点（head 节点不总是为队首节点，减少了CAS更新 head 节点的次数，提高入队效率）： 若 head 节点有元素，不会更新head节点 若 head 节点没有元素，将 head 指向队列的首节点 123456789101112131415161718192021222324252627282930public E poll() &#123; restartFromHead: for (;;) &#123; for (Node&lt;E&gt; h = head, p = h, q;;) &#123; E item = p.item; // 若头节点的值不为空，并且cas设置头节点值为null成功 if (item != null &amp;&amp; p.casItem(item, null)) &#123; // Successful CAS is the linearization point // for item to be removed from this queue. // 若当前节点不是 head 节点 if (p != h) // hop two nodes at a time // 若当前节点的下一个节点不为空，则将 head 节点指向当前节点的下一个节点，否者指向当前节点 updateHead(h, ((q = p.next) != null) ? q : p); // 返回出队的值 return item; &#125; // 若当前节点的下一个节点为空，则该队列已空，重新设置 head 节点，并返回null else if ((q = p.next) == null) &#123; updateHead(h, p); return null; &#125; // 该情况为，p是已经删除的 head 节点，继续循环 else if (p == q) continue restartFromHead; else // 重新赋值p节点 p = q; &#125; &#125; &#125; 使用场景因为其采用的是无锁的方式，所以能够满足高并发情况下的需求，其性能优于BlockingQueue。缺点在于其size()方法为一个O(n)时间复杂度的方法，并且返回的值并不是一个准确的值，所以在实际应用中，无法有效获取队列中节点的个数。","categories":[{"name":"Java","slug":"Java","permalink":"https://orechou.live/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://orechou.live/tags/Java/"},{"name":"并发容器","slug":"并发容器","permalink":"https://orechou.live/tags/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"}]},{"title":"ORM & JPA  & Spring Data JPA 之间的关系","slug":"old/JPA & ORM & Spring Data JPA 之间的关系","date":"2018-06-12T12:54:30.000Z","updated":"2018-06-12T12:54:30.000Z","comments":true,"path":"old/JPA & ORM & Spring Data JPA 之间的关系/","link":"","permalink":"https://orechou.live/old/JPA%20&%20ORM%20&%20Spring%20Data%20JPA%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","excerpt":"这篇文章主要梳理一下 ORM &amp; JPA &amp; Spring Data JPA 三者之间的关系，后面会写一篇现在主流 ORM 框架（Hibernate、Mybatis）的文章。","text":"这篇文章主要梳理一下 ORM &amp; JPA &amp; Spring Data JPA 三者之间的关系，后面会写一篇现在主流 ORM 框架（Hibernate、Mybatis）的文章。 ORMWhat对象关系映射( Object Relational Mapping，简称 ORM ），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。 Why在原来 Java 对数据库的访问是通过 JDBC（Java Database Connectivity），JDBC 提供了一组 Java API 来访问数据库。使用 JDBC 开发应用程序的优缺点如下： JDBC 的优点 JDBC 的缺点 干净整洁的 SQL 处理 大项目中使用很复杂 大数据下有良好的性能 很大的编程成本 对于小应用非常好 没有封装 易学的简易语法 难以实现 MVC 的概念 针对 JDBC 存在的缺点，一些厂商开发了 ORM 框架来弥补。比如：Hibernate、iBatis（MyBatis）、openJDK等。使用 ORM 的优点如下： 序号 优点 1 一个 API 来在持久类的对象上实现基本的 CRUD 操作 2 一个语言或 API 来指定引用类和属性的查询 3 一个可配置的服务用来指定映射元数据 4 一个技术和事务对象交互来执行 dirty checking, lazy association fetching 和其它优化的功能 但是现在也出现了一个问题， ORM 框架这么多，大家各自搞自己的，没有一个统一的规范。所以 JPA 就出现了。 JPAWhatJava Persistence API（JPA）即Java持久层API，是一种Java应用程序编程接口规范，它描述了在使用Java平台标准版和Java平台企业版的应用程序中管理关系数据。 持久层是一个包括了以下三个方面的技术： 定义在 javax.persistence 包下的API本身：用来操作实体对象，执行CRUD操作，框架在后台替代我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。 Java持久层查询语言（JPQL）：这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。 对象关系元数据：JPA支持XML和JDK5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中 WhySun引入新的JPA ORM规范出于两个原因：其一，简化现有Java EE和Java SE应用开发工作；其二，Sun希望整合ORM技术，实现天下归一。开发者面向 JPA 规范的接口，但底层的 JPA 实现可以任意切换：觉得 Hibernate 好的，可以选择Hibernate JPA 实现；觉得 TopLink 好的，可以选择 TopLink JPA 实现。 JPA 只是提供了一个接口规范，在实际的工程应用中，光靠 JPA 做不了实际的事情。 Spring Data JPAWhat官方给出的定义：Spring Data JPA 可以轻松实现基于JPA的存储库。该模块处理对基于JPA的数据访问层的增强支持。它使构建使用数据访问技术的Spring应用程序变得更加容易。 Why在一段时间内实现应用程序的数据访问层很麻烦。需要编写太多的样板代码才能执行简单查询以及执行分页和审计。 Spring Data JPA旨在通过减少实际需要的数量来显着改进数据访问层的实现。作为开发人员，您需要编写存储库接口（包括自定义查找程序方法），Spring将自动提供实现。 这样就清楚了，Spring Data JPA 增强了基于 JPA 的数据访问层的支持，并且对于底层的 ORM 提供了自动的实现（Spring Data JPA 底层 ORM 就是通过 Hibernate 实现的）。 SummaryORM 框架提供了面向对象方式，方便了开发人员对数据库的操作。各大厂商各自的 ORM 设计发展需要一个规范统一起来，是 JPA 出现的主要原因。在 Java Web 领域的巨头 Spring 推出的 Spring Data JPA 即增强了 JPA，又屏蔽掉了底层 ORM 的实现。极大程度地方便了开发者。最后可以通过如下的图描述三者之间的关系：","categories":[{"name":"Java","slug":"Java","permalink":"https://orechou.live/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://orechou.live/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"https://orechou.live/tags/JPA/"}]},{"title":"JavaScript 严格模式","slug":"old/JS 严格模式","date":"2018-06-12T12:54:28.000Z","updated":"2018-06-12T12:54:28.000Z","comments":true,"path":"old/JS 严格模式/","link":"","permalink":"https://orechou.live/old/JS%20%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","excerpt":"概述ECMAScript 严格模式是采用具有限制性 JavaScript 变体的一种方式。其目的主要有以下几点： 消除 JavaScript 语法的一些不合理、严谨的地方，减少一些怪异行为 消除代码运行的一些不安全之处，保证代码运行的安全 提高编译器效率，增加运行速度 为未来版本的 JavaScript 做好铺垫","text":"概述ECMAScript 严格模式是采用具有限制性 JavaScript 变体的一种方式。其目的主要有以下几点： 消除 JavaScript 语法的一些不合理、严谨的地方，减少一些怪异行为 消除代码运行的一些不安全之处，保证代码运行的安全 提高编译器效率，增加运行速度 为未来版本的 JavaScript 做好铺垫 使用方式对于脚本将 use strict 放在整个脚本的第一行（必须放置在第一行，否则无效），整个脚本以严格模式运行。 1234&lt;script&gt; &quot;use strict&quot; console.log(&quot;This is in strict mode.&quot;)&lt;/script&gt; 上面的写法有缺点，当有多个脚本文件的时候，不利于文件的合并。变通的做法是将整个脚本文件放在立即执行的匿名函数中 1234(function() &#123; &#x27;use strict&#x27; // follow codes&#125;)(); 将 use strict 放在函数的第一行，整个函数以严格模式运行 1234function strict() &#123; &#x27;use strict&#x27; console.log(&#x27;This is in strict mode.&#x27;)&#125; 带来的改变全局变量必须显示声明123&#x27;use strict&#x27;v = 1 // 报错。v 未声明for (i = 0; i &lt; 10; i++) &#123;&#125; // 报错。i 未声明 禁止使用 with 语句1234567&#x27;use strict&#x27;var v = 1// 严格模式限制了一些动态绑定// 在这里 with 语句无法在编译时确定属性归属于哪个对象with (o) &#123; // 语法错误 v = 2&#125; eval 作用域正常模式下有两种作用域（ scope ）：全局作用域、函数作用域。严格模式下有了第三种作用域， eval 作用域 12345&#x27;use strict&#x27;var v = 1// eval 创建了自身的作用域，它所生成的变量只用于 eval 内部console.log(eval(&#x27;var v = 2; v&#x27;)) // 输出 2console.log(v) // 输出 1 禁止 this 指向全局对象1234567function f() &#123; return !this // false, this 为全局对象，不为 null 和 undefined，所以返回 false&#125;function f() &#123; &#x27;use strict&#x27; return !this // true, this 不指向全局对象，为 undefined&#125; 禁止在函数内部遍历调用栈123456function f() &#123; &#x27;use strict&#x27; // properties may not be accessed on strict mode functions or the arguments objects for calls to them f.caller // 报错 f.arguments // 报错&#125; 删除变量或属性的限制12345678910111213141516&#x27;use strict&#x27;var a = 1delete a // 报错，禁止删除变量var obj = Object.create(null, &#123; &#x27;a&#x27;: &#123; value: 1, configurable: true &#125;, &#x27;b&#x27;: &#123; value: 2, configurable: false &#125;&#125;)// 只有 configurable 为 true 的对象属性才能被删除delete obj.a // 成功delete obj.b // 失败 显示报错正常模式下有些行为会失败，不会报错；严格模式下将报错，情况如下： 对一个对象的只读属性赋值 对一个只使用 getter 方法读取的属性赋值 对禁止扩展的对象添加新属性 删除一个不可删除的属性 重名的错误情况如下： 对象不能有重名的属性 函数不能有重名的参数 123456&#x27;use strict&#x27;var obj = &#123; p: 1, p: 2 &#125;function f(a, a, b) &#123;&#125; 禁止八进制表示法123&quot;use strict&quot;;// 正常模式下，整数的第一位如果是0，表示这是八进制数var a = 0100; // 语法错误 arguments 对象的限制arguments 对象是所有非箭头函数中都可用的局部变量 限制如下： 不允许对 arguments 赋值 arguments 不再追踪参数变化 禁止使用 arguments.callee 12345678910111213141516171819202122232425262728&quot;use strict&quot;;// 不允许对 arguments 赋值arguments++; // 语法错误var obj = &#123; set p(arguments) &#123; &#125; &#125;; // 语法错误try &#123; &#125; catch (arguments) &#123; &#125; // 语法错误function arguments() &#123; &#125; // 语法错误var f = new Function(&quot;arguments&quot;, &quot;&#x27;use strict&#x27;; return 17;&quot;); // 语法错误// arguments 不再追踪参数变化function f(a) &#123; a = 2; return [a, arguments[0]];&#125;f(1); // 正常模式为[2,2]function f(a) &#123; &quot;use strict&quot;; a = 2; return [a, arguments[0]];&#125;f(1); // 严格模式为[2,1]// 禁止使用 arguments.callee&quot;use strict&quot;;var f = function() &#123; // argumens.callee 指向当前执行的函数 return arguments.callee; &#125;;f(); // 报错 函数不能声明在非函数的代码块中1234&quot;use strict&quot;;if (true) &#123; function f() &#123; &#125; // 语法错误&#125; 新增加的保留字implements, interface, let, package, private, protected, public, static, yield 保留字无法作为变量名","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://orechou.live/categories/JavaScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://orechou.live/tags/JS/"}]},{"title":"Tensor Decomposition in TensorLy","slug":"old/TensorLy_In_Action","date":"2018-04-01T12:18:57.000Z","updated":"2018-04-01T12:18:57.000Z","comments":true,"path":"old/TensorLy_In_Action/","link":"","permalink":"https://orechou.live/old/TensorLy_In_Action/","excerpt":"最近因论文需要而学习张量和张量分解。看了诸多论文之后，想使用一些开源工具来实际操作一下张量。就选择了TensorLy，选择它的原因主要因为它文档写得详细…","text":"最近因论文需要而学习张量和张量分解。看了诸多论文之后，想使用一些开源工具来实际操作一下张量。就选择了TensorLy，选择它的原因主要因为它文档写得详细… QuickSort1.What is TensorLy传送门在这里。TensorLy是一个简单快速的Python张量库，优点在于纯Python实现，依赖少，并且能够支持如Numpy、MXnet多种数据的底层。最重要的是文档详细。 2.Basic Operations1.Import the library首先要引入相应的库才能使用 12import numpy as npimport tensorly as tl 2.Create a tensor使用numpy生成一个三维数组，并构建成TensorLy中的张量 1tensor = tl.tensor(np.arange(24).reshape((3, 4, 2))) 3.Unfolding tensor by mode将张量按维度展开 12import tensorly as unfoldunfold(tensor, 0) # mode-1 unfolding 4.Folding tensor将展开的数组按维度还原成张量 1234from tensorly import foldunfolding = unfold(tensor, 1)original_shape = tensor.shapefold(unfolding, 1, original_shape) 3.Tensor decomposition张量分解有很多种分解方法，但主要的分解方法有两种：Tucker分解和CP分解，其中CP分解是Tucker分解的一个特例。TensorLy也提供了这两种方法的实现。Tucker分解的公式为 X = S * A * B * C，X是原张量，S为分解之后产生的核心张量，A、B、C分别为分解之后关于3个维度的矩阵。图示如下： 1234from tensorly.decomposition import tucker# tucker函数传入一个张量，并指定核心张量的各个维度的长度# tucker函数的返回结果是分解完成之后的核心张量，和各个维度的矩阵core, factors = tucker(tensor, ranks=[2, 3, 1]) CP分解是Tucker分解的特例。如果Tucker分解中的核心张量是一个超对角结构（对角，并且三个维度的长度相等），则Tucker分解退化为CP分解。公式为 X = λ * A * B * C（带权重），X是原张量，λ矩阵为分解之后超对角张量的对角值，A、B、C分别为分解之后关于3个维度的矩阵。图示如下： 1234from tensorly.decomposition import parafac# parafac函数传入一个张量，并指定原张量的一个估计（近似）的秩# 返回的就是分解之后factors = parafac(tensor, rank=2) 4.Demo使用张量分解的的一个例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import matplotlib.pyplot as pltimport tensorly as tlimport numpy as npfrom tensorly.decomposition import parafacfrom tensorly.decomposition import tuckerfrom PIL import Imagerandom_state = 12345tl.set_backend(&#x27;numpy&#x27;)# 打开图片image_png = Image.open(&#x27;/Users/orechou/Downloads/index_1.jpg&#x27;)# 打印图片的信息print(image_png)data = np.reshape(image_png, [1000, 1500, 3])# 将值从int转变成float，因为在分解的过程中会产生浮点数image = tl.tensor(data, dtype=&#x27;float64&#x27;)def to_image(tensor): &quot;&quot;&quot;A convenience function to convert from a float dtype back to uint8&quot;&quot;&quot; im = tl.to_numpy(tensor) im -= im.min() im /= im.max() im *= 255 return im.astype(np.uint8)# Rank of the CP decompositioncp_rank = 25# Rank of the Tucker decompositiontucker_rank = [100, 100, 2]# Perform the CP decompositionfactors = parafac(image, rank=cp_rank, init=&#x27;random&#x27;, tol=10e-6)# Reconstruct the image from the factorscp_reconstruction = tl.kruskal_to_tensor(factors)# Tucker decompositioncore, tucker_factors = tucker(image, ranks=tucker_rank, init=&#x27;random&#x27;, tol=10e-5, random_state=random_state)tucker_reconstruction = tl.tucker_to_tensor(core, tucker_factors)# Plotting the original and reconstruction from the decompositionsfig = plt.figure()ax = fig.add_subplot(1, 3, 1)ax.set_axis_off()ax.imshow(to_image(image))ax.set_title(&#x27;Original&#x27;)ax = fig.add_subplot(1, 3, 2)ax.set_axis_off()ax.imshow(to_image(cp_reconstruction))ax.set_title(&#x27;CP&#x27;)ax = fig.add_subplot(1, 3, 3)ax.set_axis_off()ax.imshow(to_image(tucker_reconstruction))ax.set_title(&#x27;Tucker&#x27;)plt.tight_layout()plt.show() 效果如下：","categories":[{"name":"Python","slug":"Python","permalink":"https://orechou.live/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://orechou.live/tags/Python/"},{"name":"Tensor","slug":"Tensor","permalink":"https://orechou.live/tags/Tensor/"}]},{"title":"Spring Web Flow","slug":"old/spring_flow","date":"2016-11-21T03:34:27.000Z","updated":"2016-11-21T03:34:27.000Z","comments":true,"path":"old/spring_flow/","link":"","permalink":"https://orechou.live/old/spring_flow/","excerpt":"","text":"本Blog内容主要基于《Spring In Action》第四版和Github上面的sample。The first production ready 1.0 release was made on 2006-10-26. Version 2.0, first released on 2008-04-29。从那之后就没有大的版本更新。 1、在Spring中配置Web Flow《Spring In Action》第四版说“还不支持在Java中配置Spring Web Flow”，但是实际上已经支持了Java的配置。主要在代码中继承并实现AbstractFlowConfiguration接口。首先做好SpringMVC的Java配置。因为Spring Web Flow是构建于SpringMVC基础之上，所有的请求都需要首先经过SpringMVC的DispatcherServlet。（1）装配流程执行器实现一个继承了AbstractFlowConfiguration的类。 @Bean public FlowExecutor flowExecutor() &#123; return getFlowExecutorBuilder(flowRegistry()) .addFlowExecutionListener(new SecurityFlowExecutionListener(), &quot;*&quot;) .build(); &#125;流程执行器驱动流程的执行，当用户进入一个流程时，流程执行器会为用户创建并启动一个流程执行实例。（2）配置流程注册表加载流程定义并让流程执行器能够使用它们。 @Bean public FlowDefinitionRegistry flowRegistry() &#123; return getFlowDefinitionRegistryBuilder(flowBuilderServices()) .setBasePath(&quot;/WEB-INF&quot;) .addFlowLocationPattern(&quot;/**/*-flow.xml&quot;).build(); &#125;（3）处理流程请求需要配置一个FlowHandlerMapping来帮助DispatcherServlet将流程的请求发送给Spring Web Flow。 @Bean public FlowHandlerMapping flowHandlerMapping() &#123; FlowHandlerMapping handlerMapping = new FlowHandlerMapping(); handlerMapping.setOrder(-1); handlerMapping.setFlowRegistry(this.webFlowConfig.flowRegistry()); return handlerMapping; &#125;这里面装配了流程注册表，这样就能够知道如何将请求的URL匹配到流程上。配置这个Bean的作用只是将流程请求定向到swf，但是并不做响应。 @Bean public FlowHandlerAdapter flowHandlerAdapter() &#123; FlowHandlerAdapter handlerAdapter = new FlowHandlerAdapter(); handlerAdapter.setFlowExecutor(this.webFlowConfig.flowExecutor()); handlerAdapter.setSaveOutputToFlashScopeOnRedirect(true); return handlerAdapter; &#125;我们可以看到这里面设置了流程的执行器，类似于SpringMVC中的控制器，它会响应发送的请求，并对其进行处理。 2、流程的组件在Spring Web Flow中，流程是由状态(state)、转移(transition)、流程数据(data)三个元素定义。状态类型：行为(action)、决策（decision）、结束（end）、子流程(subflow)、视图(view)(视图状态用于为用户展现信息并使用户在流程中发挥作用，也即是用于交互)视图状态id:标示这个状态；若在这个状态中没有用view指定视图，则这个id也代表了视图名。model:将会把id视图中的表单数据绑定到model中所指定的对象。行为状态会出发spring中所管理bean的一些方法，方法执行调用之后会转移到另一个状态。决策状态若流程不是线性的，则需要使用决策状态子流程状态结束状态用于流程的结束。当结束的是子流程，子流程结束之后，调用它的流程将会从调用处继续执行。 状态之间的迁移to用于指定流程的下一个状态on用于指定触发转移的事件on-exception用于制定了要转移的异常&lt;global-trasitions&gt;全局转移，对于定义的流程转移，所有的状态都会默认拥有这个转移 3、流程数据可以在流程中定义变量，定义的变量可以在流程中的各个地方进行引用。&lt;var name=&quot;&quot; class=&quot;&quot;&gt;","categories":[],"tags":[]},{"title":"OSWorkflow","slug":"old/解析tern工作流","date":"2016-11-20T09:38:34.000Z","updated":"2016-11-20T09:38:34.000Z","comments":true,"path":"old/解析tern工作流/","link":"","permalink":"https://orechou.live/old/%E8%A7%A3%E6%9E%90tern%E5%B7%A5%E4%BD%9C%E6%B5%81/","excerpt":"","text":"特点：没有好的可视化工具，2.8.0是最新的版本，但这已经是07年的版本。目前官网已经没有对他提供更新。原理：主要基于有限状态机（Finite state machine），将每一个状态描述成流程中的一个步骤。jar包：osworkflow、oscore、propertySet。 1、基本概念工作流描述文件，一个xml文件。wrokflow:一个根元素，代表了一个工作流。一般由多个step构成，step表示一个流程。step:每一个步骤中可以有一个或者多个action，action表示一个动作。每执行完一个步骤，就会走向下一个步骤。在不同的步骤之中流程的状态可以不断的改变，状态类别可以设置。action:每一个动作可以有一个无条件结果unconditional result和零到多个conditional result条件结果。在result中指定完成之后的状态，并指定跳转的下一个步骤。在beanshell 表达式范围内中始终存在三个变量，entry、context和store，分别是WorkflowEntry、WorkflowContext、WorkflowStore三个对象。beanshell是一种完全符合java语法的脚本语言，可以理解为可以在beanshell中编写java代码。 2、实现细节1、配置数据库，这是你工作流中数据流转的数据库来源。可以选择xml配置模式。在传统的动态web工程的server.xml文件中，设置好数据库驱动。Tern将所有配置信息保存在Java代码中。2、持久化（Persistence）。内置提供了：MemoryStore、SerializableStore、JDBCStore方式。也可以自己继承WorkflowStore接口，实现自己的需求。3、载入流程定义文件（WorkflowFactory）读取编写好的xml，将流程载入。可以继承AbstractWorkflowFactory来实现自己的需求。 3、Tern框架里实现1、流程服务（Service.class）Service用于定义好流程的ID，流程的名称 ，流程所关联的实体数据表名称。此处的流程不是指的具体的流程，而是指的一种流程。主要的属性：流程ID，流程名称，流程描述，流程关联的实体数据（可以有实体类类名，也可以是该实体类在数据库中的表名）。在后面新建立一个流程的时候都要通过这个类去获取一种流程，然后新增一个流程实例。2、流程实例（Process.class）Process用于定义一个具体的流程。也即是是通过Service生成的一个流程实例。主要的属性：流程ID，流程服务ID，实体数据ID，流程描述，发起者ID，发起时间，结束时间，序列号，状态3、工作流记录（WorkflowEntry.class）WorkflowEntry用于定义描述一个工作流实例。主要属性：工作流名称、工作流状态、是否已经初始化、id在tern中对WorkflowEntry进行了扩展，增加了record(实体数据记录)、user(当前操作员)、service(该工作流对应的流程服务)、process(该工作流的流程实例)WorkflowEntry的id在新建的时候被赋值为process的id4、工作流持久化（WorkflowStore）用于数据的持久化。tern扩展继承了JDBCWorkflowStore。主要的功能是负责管理流程的执行过程。主要的功能函数：findSteps去获取数据库中已经进行的流程步骤。可传入多种参数entryId，stategetNextEntrySequence获取下一步流程的序列号createEntry新增一个WorkflowEntry实例findCurrentSteps();findHistorySteps();createCurrentStep();tern在数据库中建立了表wf_stepinfo，上面的方法都是对wf_stepinfo进行操作。5、工作流工厂主要的负责流程的定义方面。WorkflowDescriptor在OSWorkflow中表示一个处理之后的流程6、工作流引擎（Workflow.class）tern实现了OSWorkflow提供的工作流引擎的接口。tern将工作流引擎设计为单例模式。引擎中设置了环境上下文(Context)，里面存储了当前登录的操作员。引擎中持有了一个运行当前工作流的线程对象。主要的功能函数：（1）createInstance()：创建工作流的实例，即通过Service和实体数据record创建一个流程。这一步会在数据库中getAvailableActions()：函数中根据WorkflowStore，IAPWorkflowEntry，WorkflowDescriptor这三个对象，获取到当前步骤中可做的动作ActionsgetPermissionHandler()：根据传入的WorkflowDescriptor和工作流引擎中存储的操作员，可以判断出当前操作员的角色是否有权限参与流程getCurrentSteps();getEntryState();getHistorySteps();：调用了WorkflowStore里面的方法initialize()：新增一个工作流条目，changeEntryState()：变更工作流条目的状态COMPLETED,CREATED,ACTIVATED,SUSPENDED,KILLED。doAction()：做工作流里面的操作。entry、propertySet、transientVars这些变量可通过","categories":[],"tags":[]},{"title":"Tern Model层解析","slug":"old/解析tern框架Model层","date":"2016-11-08T08:54:26.000Z","updated":"2016-11-08T08:54:26.000Z","comments":true,"path":"old/解析tern框架Model层/","link":"","permalink":"https://orechou.live/old/%E8%A7%A3%E6%9E%90tern%E6%A1%86%E6%9E%B6Model%E5%B1%82/","excerpt":"","text":"com.tern.dbdb对JDBC做了封装，提供了一系列的对数据库的操作。函数提供了链式的操作。db获取app.yml中的配置进行数据库的连接(ConnectionPool类)，支持了如MySql、Oracle、Sqlite等多种数据库。查询等获取的数据库的数据以DataTable（返回一张表的数据），或者以DataRow（返回一条数据行的数据）\u0010作为对象返回。 com.tern.daodao是对db的再一次做的封装，从而满足MVC中的Model层的要求。\u0010 1、Modeldao中的核心类之一，实现了数据模型的封装。其定义了数据表名称、所包含的列（属性）的信息（如：列名、列数据类型、约束条件）和与其他模型之间的关系信息。MoodelReader是模型的读取器（抽象类），DefaultModelReader（数据库元数据读取）、YamlModelReader（Yaml文件读取）、DBModelReader（数据库读取）是三个实现。 获取Model的方法form(String name, Database db)这是一个静态工厂方法，它实际去调用protected声明的构造方法Model(String name, Database h)，该构造方法中，首先尝试去从yaml中读取数据模型的schema，若不存在的话才会去数据库中获取schema。构造方法中调用ModelReader的实现类去读取schema，读取columns的信息、caption、title等数据并解析（这些数据都是以键值对的形式作存储，map，方便解析)。在元数据库中存储了对于Model定义、Model的列/字段定义、Model之间的关系定义、关系中的字段映射关系的数据，分别为iap_entities、iap_columns、iap_relations、iap_relation_map这几张表。 2、Record抽象意义是一条数据记录。Recrod是一个实现了Map&lt;String, Object&gt;接口的类。每一个Record类的内部都持有该数据记录的model，row即是该Record数据中的所有列的键值对。有这两个内部实例，Record类即可表示所有定义了Model的实际数据库对象。 3、RecordSet抽象意义是数据记录的集合。其持有数据模型model，还有一个Query类（db提供的数据库查询的工具类）。通过model中的表名称，和Query类，RecordSet可以查询数据库中并返回记录。返回的记录以RecordSet的对象存储。RecordSet定义了很多访问数据库返回数据的方法。 4、Model中的CURDModel中提供了query(String where, Object[] params)等方法，读取数据库，返回RecordSet数据。其实是调用了RecordSet的方法。另外Model提供了新增、删除、修改的方法。 总结com.tern.db的封装是提供一种访问数据库的简便方法，com.tern.dao的封装是提供一种操作模型简便方法。简单来说，在实际开发之中设计好数据库之后，可以先行一步配置好Model，tern平台提供了ide的网页平台将Model录入进元数据库中。这样做的好处是，不用在实际的项目之中再编写entity类，因为模型model已经存在，而且得益于record的抽象。Model可以去数据库读取数据，而返回的数据可以用record的容纳。","categories":[],"tags":[]},{"title":"Sept-11-2016","slug":"old/Sept-11-2016","date":"2016-09-11T15:29:54.000Z","updated":"2016-09-11T15:29:54.000Z","comments":true,"path":"old/Sept-11-2016/","link":"","permalink":"https://orechou.live/old/Sept-11-2016/","excerpt":"","text":"暑假回家了10天，在学校体验了几周的早班地铁，体会了挤地铁的艰辛。本来有说的技术博客也变成了一两个月的牢骚。明天开学第一课，是时候再发一波骚气了。 关于项目：CPMS系统开发一个MIS系统，都要针对该MIS系统所设计的行业有一个比较透彻的了解，要补习一些IT行业外的知识。另外开发任何一个系统，都要与业主有很好的沟通。参与这个项目，我的感觉是沟通不够。两个问题，我没有主动沟通的积极性，二是没有对沟通的有一定的重视程度。沟通和另外的一些原因于，导致该项目的停滞不前、进度缓慢。 关于研究生9月来学校，我去了一趟虎溪——大学开始的地方。没有多逛，从大学城地铁站、走熙街、穿过北门南门、最后回沙坪坝。回忆起本科这四年，业精于勤荒于嬉。对于后面这三年，我想，是该骚气地做一波改变了。 关于写东西每次想写，都写不了多少。。。","categories":[],"tags":[]},{"title":"July-9-2016","slug":"old/July-9-2016","date":"2016-07-09T13:26:52.000Z","updated":"2016-07-09T13:26:52.000Z","comments":true,"path":"old/July-9-2016/","link":"","permalink":"https://orechou.live/old/July-9-2016/","excerpt":"","text":"距离上篇博文已经过去了两个月，寻思再不更新些什么，这个Blog的意义也就不在了。今日不更新，以后也不会更新了。这两个月，毕业、约会、做项目，另外还去了一趟澳门。很感谢我的导师——葛老师带给的这次机会，去见识了一下澳门的赌场和一些优秀的计算机idea。 关于项目从五月份开始做的项目是为重庆市城市建设发展有限公司做的一个项目管理web软件。从最开始接触tern框架开始，再慢慢接触业务逻辑，到后面对项目的思考。这一个多月还是挺有收获，主要有以下几点：1、参与了完整的项目开发；2、锻炼了前端与后端的编程能力（从页面设计到服务器API的编写）；3、框架底层代码的阅读（自己调试bug的时候，会深入去看一看框架底层的代码。例如：数据库的再次封装的代码；线程池分配的代码）。昨天带着项目简陋版本去业主方展示，对于业主方的需求，目前的web app还有很多东西要去实现。 关于毕业毕业只有几句话说。天之涯，地之角，知交半零落。一壶浊酒尽馀欢，今宵别梦寒。祝各位前程似锦，珍重。 关于澳门此次去澳门是参加泛珠三角计算机作品赛。认识了几位科技学院的同学，见识了赌场。葛老师还请吃了猪扒包和澳门蛋挞。😄","categories":[],"tags":[]},{"title":"May-8-2016","slug":"old/May-8-2016","date":"2016-05-08T15:28:46.000Z","updated":"2016-05-08T15:28:46.000Z","comments":true,"path":"old/May-8-2016/","link":"","permalink":"https://orechou.live/old/May-8-2016/","excerpt":"","text":"今天晚上刚把毕业论文写好发给导师。这周已经开始跟导师做项目了。老师同学做的一个JavaWeb开发框架——tern，该框架已经在GitHub上开源。我们使用这个JavaWeb框架开发WebApp。一期项目是做一个面向企业用户的项目管理系统CPMS。熟悉这个框架有一周多的时间，谈一谈自己的感受：1、相比于SSH、亦或是SpringMVC，tern很轻量级。在配置工程上，几乎不需要做什么配置。2、对于基本的数据库支持很完善，数据库查询功能齐全。可能不足的地方在于web性能问题，该框架不适用于开发大型的用户量大的网站。3、具有很大的复用性，该框架很适合于开发企业的管理应用系统。目前开源的Tern分为三个部分：tern、tern-ui、tern-iap。根据作者乔老师所说，tern与tern-ui已经接近完善、不会再有改变，tern-iap仍在开发完善之中。大三学习web开发的时候没有学习前端知识，目前做项目的过程中，要对前端知识有一定的掌握。所以这周也在学习前端，web前端技术：HTML、CSS、JavaScript，我主要深入学习JavaScript。JavaScript的学习意义不止在于制作前端页面，更在于前端业务逻辑与前端数据与UI的交互。剩下的HTML和CSS，在目前的学习中，就是用到的时候Google一下就ok。我们在项目中前端用到的技术有：Bootstrap、JQuery（选择器省去我好多工作量）和FreeMarker。FreeMarker用于使用Java语言定义前端UI模板、指令标签，并且还有将数据库中所得数据与模板结合展示的作用。学习三门技术的最好途径就是上官网，看官网给的示例，然后根据项目一步一步实践。 ok。第一篇周记就这些。","categories":[],"tags":[]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://orechou.live/categories/Linux/"},{"name":"Network","slug":"Linux/Network","permalink":"https://orechou.live/categories/Linux/Network/"},{"name":"Java","slug":"Java","permalink":"https://orechou.live/categories/Java/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://orechou.live/categories/JavaScript/"},{"name":"Python","slug":"Python","permalink":"https://orechou.live/categories/Python/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://orechou.live/tags/Java/"},{"name":"JUC","slug":"JUC","permalink":"https://orechou.live/tags/JUC/"},{"name":"middleware","slug":"middleware","permalink":"https://orechou.live/tags/middleware/"},{"name":"Kafka","slug":"Kafka","permalink":"https://orechou.live/tags/Kafka/"},{"name":"investment","slug":"investment","permalink":"https://orechou.live/tags/investment/"},{"name":"cyber weekly","slug":"cyber-weekly","permalink":"https://orechou.live/tags/cyber-weekly/"},{"name":"Reading","slug":"Reading","permalink":"https://orechou.live/tags/Reading/"},{"name":"Spring","slug":"Spring","permalink":"https://orechou.live/tags/Spring/"},{"name":"密码学","slug":"密码学","permalink":"https://orechou.live/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"Tools","slug":"Tools","permalink":"https://orechou.live/tags/Tools/"},{"name":"Efficiency","slug":"Efficiency","permalink":"https://orechou.live/tags/Efficiency/"},{"name":"Life","slug":"Life","permalink":"https://orechou.live/tags/Life/"},{"name":"Other","slug":"Other","permalink":"https://orechou.live/tags/Other/"},{"name":"Song","slug":"Song","permalink":"https://orechou.live/tags/Song/"},{"name":"iOS","slug":"iOS","permalink":"https://orechou.live/tags/iOS/"},{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://orechou.live/tags/SwiftUI/"},{"name":"MySQL","slug":"MySQL","permalink":"https://orechou.live/tags/MySQL/"},{"name":"Linux","slug":"Linux","permalink":"https://orechou.live/tags/Linux/"},{"name":"Network","slug":"Network","permalink":"https://orechou.live/tags/Network/"},{"name":"Socket","slug":"Socket","permalink":"https://orechou.live/tags/Socket/"},{"name":"JS","slug":"JS","permalink":"https://orechou.live/tags/JS/"},{"name":"并发容器","slug":"并发容器","permalink":"https://orechou.live/tags/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"},{"name":"JPA","slug":"JPA","permalink":"https://orechou.live/tags/JPA/"},{"name":"Python","slug":"Python","permalink":"https://orechou.live/tags/Python/"},{"name":"Tensor","slug":"Tensor","permalink":"https://orechou.live/tags/Tensor/"}]}