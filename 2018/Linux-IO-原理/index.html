<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="在上一篇文章中主要介绍了 Java NIO 相关基础和 Reactor 模式，NIO 的实现在不同的平台上依赖于操作系统所提供的系统调用。下面将介绍 NIO 在 Linux 平台上的底层实现原理。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux IO 原理">
<meta property="og:url" content="https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="奥力手记">
<meta property="og:description" content="在上一篇文章中主要介绍了 Java NIO 相关基础和 Reactor 模式，NIO 的实现在不同的平台上依赖于操作系统所提供的系统调用。下面将介绍 NIO 在 Linux 平台上的底层实现原理。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://orechou.com/images/unix_kernel.png">
<meta property="og:image" content="https://orechou.com/images/linux_address.jpeg">
<meta property="og:image" content="https://orechou.com/source/images/file_read.png">
<meta property="og:image" content="https://orechou.com/source/images/file_write.png">
<meta property="og:image" content="https://orechou.com/images/file_copy.gif">
<meta property="og:image" content="https://orechou.com/images/file_copy_2.gif">
<meta property="og:image" content="https://orechou.com/images/zero_copy.gif">
<meta property="og:image" content="https://orechou.com/images/zero_copy_2.gif">
<meta property="og:image" content="https://orechou.com/images/block_io.png">
<meta property="og:image" content="https://orechou.com/images/noblock_io.png">
<meta property="og:image" content="https://orechou.com/images/io_multiplexing.png">
<meta property="og:image" content="https://orechou.com/images/asynchronous_io.png">
<meta property="og:image" content="https://orechou.com/images/io_compare.png">
<meta property="article:published_time" content="2018-09-19T08:40:37.000Z">
<meta property="article:modified_time" content="2018-09-19T08:40:37.000Z">
<meta property="article:author" content="OreChou">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://orechou.com/images/unix_kernel.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Linux IO 原理</title>
    <!-- async scripts -->
    <!-- Google Analytics -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-9RBGC8GJC6"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-9RBGC8GJC6');
  </script>


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="奥力手记" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/book/">Book</a></li><!--
     --><!--
       --><li><a href="/application/">Apps</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2018/Linux-%E5%91%BD%E4%BB%A4/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2018/Java%20NIO/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&text=Linux IO 原理"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&title=Linux IO 原理"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&is_video=false&description=Linux IO 原理"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Linux IO 原理&body=Check out this article: https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&title=Linux IO 原理"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&title=Linux IO 原理"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&title=Linux IO 原理"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&title=Linux IO 原理"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&name=Linux IO 原理&description=&lt;p&gt;在上一篇&lt;a href=&#34;http://orechou.github.io/2018/09/15/Java-Java-NIO/&#34;&gt;文章&lt;/a&gt;中主要介绍了 Java NIO 相关基础和 Reactor 模式，NIO 的实现在不同的平台上依赖于操作系统所提供的系统调用。下面将介绍 NIO 在 Linux 平台上的底层实现原理。&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&t=Linux IO 原理"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">操作系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB-Unix-%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">类 Unix 的体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81-amp-%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">用户态 &amp; 内核态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.</span> <span class="toc-text">Linux 进程地址空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-number">2.</span> <span class="toc-text">数据读写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.</span> <span class="toc-text">读数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.</span> <span class="toc-text">写数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF"><span class="toc-number">2.3.</span> <span class="toc-text">零拷贝技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">传统方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.3.2.</span> <span class="toc-text">零拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-IO-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">Linux IO 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E-IO%EF%BC%88Blocking-IO%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">阻塞 IO（Blocking IO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E-IO%EF%BC%88NonBlocking-IO%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">非阻塞 IO（NonBlocking IO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-IO%EF%BC%88IO-Multiplexing%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">多路复用 IO（IO Multiplexing）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-IO%EF%BC%88Asynchronous-IO%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">异步 IO（Asynchronous IO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">3.5.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">多路复用的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#select"><span class="toc-number">4.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poll"><span class="toc-number">4.2.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll"><span class="toc-number">4.3.</span> <span class="toc-text">epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.3.1.</span> <span class="toc-text">步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-create"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">epoll_create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-ctl"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">epoll_ctl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-wait"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">epoll_wait</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">工作模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Linux IO 原理
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">OreChou</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2018-09-19T08:40:37.000Z" class="dt-published" itemprop="datePublished">2018-09-19</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Linux/">Linux</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Java/" rel="tag">Java</a>, <a class="p-category" href="/tags/Linux/" rel="tag">Linux</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>在上一篇<a target="_blank" rel="noopener" href="http://orechou.github.io/2018/09/15/Java-Java-NIO/">文章</a>中主要介绍了 Java NIO 相关基础和 Reactor 模式，NIO 的实现在不同的平台上依赖于操作系统所提供的系统调用。下面将介绍 NIO 在 Linux 平台上的底层实现原理。</p>
<span id="more"></span>

<h1 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h1><p>首先了解一下类 Unix 操作系统体系结构与基本概念。</p>
<h2 id="类-Unix-的体系结构"><a href="#类-Unix-的体系结构" class="headerlink" title="类 Unix 的体系结构"></a>类 Unix 的体系结构</h2><p><img src="/images/unix_kernel.png"></p>
<p>操作系统内核（kernel）的本质是一个软件：可以控制计算机的硬件资源，并提供上层应用程序运行的环境。内核拥有可以访问受保护的空间和底层硬件设备的权限。</p>
<p>用户所编写的程序不能直接去访问内核代码，需要通过接口，这些接口被设计为系统调用（system call）。公用函数库建立在系统调用之上，应用程序即可以直接使用公用函数库，也可以使用系统调用。例如 fread 是 C 标准库函数，read 是系统调用。</p>
<p>Shell 是一个特殊的应用程序，为运行其他应用程序提供了一个接口。最外层的是应用程序。</p>
<h2 id="用户态-amp-内核态"><a href="#用户态-amp-内核态" class="headerlink" title="用户态 &amp; 内核态"></a>用户态 &amp; 内核态</h2><p>类 Unix 的体系架构可以分为用户态和内核态。操作系统将虚拟空间划分成<strong>用户空间</strong>和<strong>内核空间</strong>两个部分，并划分了特权级，Intel x86 架构的 cpu 一共有 0～3 四个特权级，数字越小，特权越高，在 Unix/Linux 中指使用了 0 和 3 两个特权级，分别表示内核态和用户态。</p>
<p>用户应用程序一般在用户态下运行，当需要操作系统介入时，就会切换到用户态。用户态到内核态的切换方式：</p>
<ul>
<li><strong>系统调用</strong>：用户态进程主动通过系统调用申请操作系统提供的服务程序。（系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断）</li>
<li><strong>异常</strong>：当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</li>
<li><strong>外设中断</strong>：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</li>
</ul>
<h2 id="Linux-进程地址空间"><a href="#Linux-进程地址空间" class="headerlink" title="Linux 进程地址空间"></a>Linux 进程地址空间</h2><p>下图是 Linux 进程的内存地址空间，以 32 位的操作系统为例。</p>
<p><img src="/images/linux_address.jpeg"></p>
<p>地址空间分成了两部分，用户空间（0x00000000 ~ 0xBFFFFFFF）和内核空间（0xC0000000 ~ 0xFFFFFFFF）。不同的进程用户空间是私有的。内核空间是持续存在的，并且是共享的，所有进程中都映射到同样的物理内存，内核代码和数据总是可寻址的，随时准备处理中断和系统调用。</p>
<p>用户空间的由如下的内容组成：</p>
<ul>
<li><strong>Text Segmet（ELF，文本段）</strong>：程序代码在内存中的映射，存放二进制代码。</li>
<li><strong>Data Segmet（初始化过的数据段）</strong>：存放程序运行时已经初始化赋值的静态变量数据（被程序员初始化）。</li>
<li><strong>BSS Segment（未初始化的数据段）</strong>：存放程序运行时未被初始化的静态变量数据。</li>
<li><strong>Heap</strong>：存储动态内存分配，需要程序员手工分配，手工释放。与数据结构中的堆是两回事，分配方式类似于链表。</li>
<li><strong>栈</strong>：当有方法的调用的时候会产生一个方法栈帧进行压栈。栈帧中存储局部、临时变量，函数调用，存储函数的返回指针，用于控制函数的调用和返回。栈帧在函数程序块开始时自动分配内存，结束时自动释放内存。</li>
</ul>
<h1 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h1><p>Linux 的数据读写有两种方式，传统的读写与零拷贝技术。传统的读写数据需要复制两次，零拷贝技术只需要复制一次。下面以文件读写为例，简要说明一下传统的读写。</p>
<h2 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h2><p><img src="/source/images/file_read.png"></p>
<p>当应用程序需要读写磁盘上的数据时，会使用内核的系统调用。数据首先通过 DMA（Direct Memory Access）将磁盘上的数据复制到内核的缓冲区中，然后应用程序再从内核缓冲区中将数据复制到应用缓冲区。</p>
<h2 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h2><p><img src="/source/images/file_write.png"></p>
<p>当应用程序需要将数据传送给另外一个客户端时，也会使用内核的系统调用。应用程序首先将数据写入到内核的 socket 缓冲区中，然后再通过 DMA 将数据发给 socket 连接的另一端。</p>
<p>DMA copy。这是一种通过硬件实现的数据传输机制。简单的说，就是不在CPU的参与下完成数据的传输。</p>
<p>CPU copy 。 相比DMA而言，copy的过程需要用到cpu 寄存器等,速度较慢。</p>
<h2 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h2><p>考虑一个应用场景，服务器程序经常需要将一些数据通过网络传输给另外一个程序。</p>
<h3 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h3><p>传统的处理方式是先将数据从磁盘上读出来，然后再将数据通过 socket 写出去。这会使用两个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File.<span class="built_in">read</span>(fileDesc, buf, len);</span><br><span class="line">Socket.<span class="built_in">send</span>(socket, buf, len);</span><br></pre></td></tr></table></figure>

<p>流程图如下：</p>
<p><img src="/images/file_copy.gif"></p>
<p>由图中我们可以看出数据一共被复制了 4 次：</p>
<ul>
<li>磁盘复制到内核 Read Buffer</li>
<li>Read Buffer 复制到用户空间 Buffer</li>
<li>用户空间 Buffer 复制到 Socket Buffer</li>
<li>Socket Buffer 复制到 NIC Buffer</li>
</ul>
<p>注：NIC（network interface card）</p>
<p>在整个过程中数据一共复制了 4 次，用户态-内核态切换了 4 次。Read 两次，Send 两次。</p>
<p><img src="/images/file_copy_2.gif"></p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>零拷贝技术让整个数据复制的过程中不需要用户的参与，即数据传输直接在内核中完成，不需要复制到用户空间的缓存中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// out_fd: socket 或者 file 都可以用 fd 表示</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p>流程图如下：</p>
<p><img src="/images/zero_copy.gif"></p>
<p>数据从磁盘复制到内核 Read Buffer 中后，直接复制到 Socket Buffer 中。</p>
<p>所以整个过程中数据只需要复制 3 次，用户态-内核态切换了两次。</p>
<p><img src="/images/zero_copy_2.gif"></p>
<h1 id="Linux-IO-模式"><a href="#Linux-IO-模式" class="headerlink" title="Linux IO 模式"></a>Linux IO 模式</h1><p>对于一次 IO 访问（以 read 举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)，即数据复制到内核的缓冲区。</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)，内核缓冲区到用户空间的缓冲区。</li>
</ol>
<p>linux 一共有下面五种 IO 模式：</p>
<ul>
<li>阻塞 IO（blocking IO）</li>
<li>非阻塞 IO（nonblocking IO）</li>
<li>IO 多路复用（ IO multiplexing）</li>
<li>信号驱动 IO（ signal driven IO）</li>
<li>异步 IO（asynchronous IO）</li>
</ul>
<p>在实际的使用中，信号驱动 IO 并不常用。</p>
<p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 Unix、Linux这样的操作系统。</p>
<h2 id="阻塞-IO（Blocking-IO）"><a href="#阻塞-IO（Blocking-IO）" class="headerlink" title="阻塞 IO（Blocking IO）"></a>阻塞 IO（Blocking IO）</h2><p>在 Linux 中所有的 IO 默认都是阻塞模式，阻塞 IO 的流程如下：</p>
<p><img src="/images/block_io.png"></p>
<p>recvfrom 是从 socket 接受数据的系统调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssize_t <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">void</span> *buf, size_t len, <span class="type">int</span> flags)</span>;</span><br><span class="line">ssize_t <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">void</span> *buf, size_t len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                 struct sockaddr *src_addr, socklen_t *addrlen)</span>;</span><br><span class="line">ssize_t <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, struct msghdr *msg, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>当使用这个系统调用的时候，内核会介入完成两部分操作：</p>
<ol>
<li>准备数据，这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要时间的，不管是复制磁盘文件中的数据，还是接收 socket 传输的数据。而等待这一个过程，用户进程会将自己阻塞。</li>
<li>当内核中的缓冲区已经将数据复制好之后，就会将数据从内核中的缓冲区复制到用户空间中的缓冲区。复制完成之后返回结果，用户进程继续执行。</li>
</ol>
<p>可以看到，用户进程在 IO 操作的两个阶段中都是被阻塞的。</p>
<h2 id="非阻塞-IO（NonBlocking-IO）"><a href="#非阻塞-IO（NonBlocking-IO）" class="headerlink" title="非阻塞 IO（NonBlocking IO）"></a>非阻塞 IO（NonBlocking IO）</h2><p>非阻塞 IO 的流程如下：</p>
<p><img src="/images/noblock_io.png"></p>
<p>在 Linux 中，可以通过以下三种方式将 IO 设置为非阻塞 IO：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建socket的时候，指定 socket 是异步的，在 type 的参数中设置 SOCK_NONBLOCK 标志即可。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"><span class="type">int</span> s = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用fcntl函数。</span></span><br><span class="line"><span class="built_in">fcntl</span>(sockfd, F_SETFL, <span class="built_in">fcntl</span>(sockfd, F_GETFL, <span class="number">0</span>) | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用ioctl函数。1:非阻塞 0:阻塞。</span></span><br><span class="line"><span class="built_in">ioctl</span>(sockfd, FIONBIO, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>非阻塞 IO 与阻塞 IO 的区别在于，在数据准备的阶段，用户进程不需要等待该阶段完成。用户进程会不断地去询问这个过程是否完成，若未完成用户进程也会收到一个回复，若已完成则开始第二阶段数据的复制。</p>
<h2 id="多路复用-IO（IO-Multiplexing）"><a href="#多路复用-IO（IO-Multiplexing）" class="headerlink" title="多路复用 IO（IO Multiplexing）"></a>多路复用 IO（IO Multiplexing）</h2><p>多路复用 IO 也被称为事件驱动 IO，流程如下：</p>
<p><img src="/images/io_multiplexing.png"></p>
<p>IO 多路复用通过 select、poll、epoll 实现。IO 多路复用优点在于单个 process 可以同时处理多个网络连接的IO。它的基本原理就是 select，poll，epoll 函数会不断的轮询所负责的所有连接的 socket，当某个 socket 有数据到达，就通知用户进程。</p>
<p>当用户调用了 select 后，用户进程需要等待 select 函数的返回，即有 socket 的数据就绪。在 Java 中的 Selector 提供了 select 方法和 selectNow 方法，前者需要等待有就绪的读写事件，而后者可以直接返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become &quot;ready&quot; for some class of I/O operation</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for some event on a file descriptor</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="异步-IO（Asynchronous-IO）"><a href="#异步-IO（Asynchronous-IO）" class="headerlink" title="异步 IO（Asynchronous IO）"></a>异步 IO（Asynchronous IO）</h2><p>异步 IO 是真正的异步非阻塞 IO，流程如下：</p>
<p><img src="/images/asynchronous_io.png"></p>
<p>用户进程发起 read 操作之后，就立刻返回开始去做其它的事。而另一方面，从 kernel 的角度，当它受到一个asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>在 non-blocking IO 中，虽然进程大部分时间都不会被 block，但是它仍然要求进程去主动的 check，并且当数据准备完成以后，也需要进程主动的再次调用 recvfrom 来将数据拷贝到用户内存。而 asynchronous IO 则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<p><img src="/images/io_compare.png"></p>
<h1 id="多路复用的原理"><a href="#多路复用的原理" class="headerlink" title="多路复用的原理"></a>多路复用的原理</h1><p>前面说到 Linux 实现多路复用是通过 select、poll、epoll 函数实现的。IO 多路复用是一种机制，这种机制提供了单个进程监听多个 IO 的能力。一个进程可以通过监听多个文件描述符，一旦某个描述符的某种事件就绪（读、写就绪），就通知程序进程读写操作。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select 函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become &quot;ready&quot; for some class of I/O operation</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span> <span class="params">(<span class="type">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>select 关注了三种描述符，readfds、writefds、exceptfds，分别是读、写和发生异常的。可以通过设置 timeout 来指定等待事件，当将 timeout 设置为 null 时，select 会立即返回。函数返回值是就绪文件描述符的数量，0 表示timeout，-1 表示出错。函数返回后要通过遍历的方式找到就绪的fd。</p>
<p>select 采用的是轮询的方式监听所有的文件描述符，单个进程能够监听的文件描述符的数量有最大限制，在Unix下通常为256，Linux 下通常为1024，可以通过修改 /sys/types.h 头文件中的 FD_SETSIZE 值然后重新编译内核进行修改。</p>
<p>缺点：</p>
<ol>
<li>可以监听的文件描述符有限。</li>
<li>以轮询的方式进行检查是否就绪效率低。</li>
<li>每次检查是否就绪要将所有需要被检查的 fd 的数据结构复制到内核，完成后修改这个数据结构并返回给程序，从用户空间到内核空间的来回拷贝将占用大量 CPU。</li>
</ol>
<p>优点：在所有的平台上都支持</p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll 函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait for some event on a file descriptor</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">int</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>poll 也是以轮询的方式进行监听，但与 select 不同的是 poll 抛弃了用位图存储文件描述符的方式，而使用 pollfd。需要监听什么事件，只需要初始化 events 即可，当 poll 函数返回时 revents 被设定为实际发生的事件。</p>
<p>缺点：</p>
<ol>
<li>以论文的方式进行检查是否就绪效率低。</li>
<li>每次检查是否就绪要将所有需要被检查的 fd 的数据结构复制到内核，完成后修改这个数据结构并返回给程序，从用户空间到内核空间的来回拷贝将占用大量 CPU。</li>
</ol>
<p>优点：</p>
<ol>
<li>监听没有最大数量的限制。</li>
<li>select 的函数返回值是三个集合中就绪态的 fd 的数量之和，因此如果同一个 fd 在不止一个集合中同时被指定，且对于多个 I/O 事件都处于就绪态的话就会被统计多次，而 poll 的返回值是不重复的。</li>
</ol>
<p>select 和 poll 都是需要通过遍历所有的文件描述符来获取已经就绪的事件，但是同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll 是在2.6内核中提出的，是之前的 select 和 poll 的增强版本。epoll更加灵活，没有描述符限制。epoll 使用一个文件描述符管理多个描述符，其他的文件描述符注册到这个描述符上，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</p>
<p>epoll 有三个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 epoll 的句柄（实例），size 用来告诉内核这个监听的数目一共有多大</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>；</span><br><span class="line"><span class="comment">// 修改 epfd 所代表的 epoll 实例的兴趣列表，即可以向 epoll 实例添加、删除、修改 fd，并设定感兴趣的事件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>；</span><br><span class="line"><span class="comment">// 返回 epoll 实例中处于就绪态的 fd 信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> events; <span class="comment">/*指定了待检查的fd所感兴趣的事件集合，用位掩码表示*/</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">/*用来在就绪后给调用进程传递信息*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><p>调用该函数创建一个句柄（称为 epoll 句柄，epfd），指定的 size 用来告诉内核这个监听的数目的大小。size 不是限制 epoll 监听描述符的最大数量，而是内核对内存使用大小的一个建议。</p>
<p>epoll 句柄是一个文件描述符，它会占用一个 fd 值。在 Linux 中通过 /proc/pid/fd/ 可看到该值。所以在使用 epoll 的程序中，使用完之后应用 close 方法关闭 epoll，否则可能会导致 fd 被消耗殆尽。</p>
<h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><p>首先将一下函数中各个参数的意义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>epfd</td>
<td>调用 epoll_create 函数产生的 epoll 句柄</td>
</tr>
<tr>
<td>op</td>
<td>用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对 fd 的监听事件。</td>
</tr>
<tr>
<td>fd</td>
<td>监听的文件描述符 fd</td>
</tr>
<tr>
<td>epoll_event</td>
<td>监听 fd 的事件</td>
</tr>
</tbody></table>
<p>函数对指定的文件描述符 fd 执行指定的 op 操作。</p>
<p>event 集合如何：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure>

<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p>参数及意义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>epfd</td>
<td>调用 epoll_create 函数产生的 epoll 句柄</td>
</tr>
<tr>
<td>events</td>
<td>从内核得到的事件集合</td>
</tr>
<tr>
<td>maxevents</td>
<td>告诉内核这个 events 有多大，该值不能大于创建 epoll_create() 时的 size</td>
</tr>
<tr>
<td>timeout</td>
<td>超时时间</td>
</tr>
</tbody></table>
<p>该函数等待 epfd 上的 IO 事件。</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>epoll 对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和 <strong>ET（edge trigger）</strong>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003063859">Linux IO模式及 select、poll、epoll详解</a>]</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/book/">Book</a></li>
        
          <li><a href="/application/">Apps</a></li>
        
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">操作系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB-Unix-%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">类 Unix 的体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81-amp-%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">用户态 &amp; 内核态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.</span> <span class="toc-text">Linux 进程地址空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-number">2.</span> <span class="toc-text">数据读写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.</span> <span class="toc-text">读数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.</span> <span class="toc-text">写数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF"><span class="toc-number">2.3.</span> <span class="toc-text">零拷贝技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">传统方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.3.2.</span> <span class="toc-text">零拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-IO-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">Linux IO 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E-IO%EF%BC%88Blocking-IO%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">阻塞 IO（Blocking IO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E-IO%EF%BC%88NonBlocking-IO%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">非阻塞 IO（NonBlocking IO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-IO%EF%BC%88IO-Multiplexing%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">多路复用 IO（IO Multiplexing）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-IO%EF%BC%88Asynchronous-IO%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">异步 IO（Asynchronous IO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">3.5.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">多路复用的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#select"><span class="toc-number">4.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poll"><span class="toc-number">4.2.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll"><span class="toc-number">4.3.</span> <span class="toc-text">epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.3.1.</span> <span class="toc-text">步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-create"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">epoll_create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-ctl"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">epoll_ctl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll-wait"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">epoll_wait</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">工作模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&text=Linux IO 原理"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&title=Linux IO 原理"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&is_video=false&description=Linux IO 原理"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Linux IO 原理&body=Check out this article: https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&title=Linux IO 原理"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&title=Linux IO 原理"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&title=Linux IO 原理"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&title=Linux IO 原理"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&name=Linux IO 原理&description=&lt;p&gt;在上一篇&lt;a href=&#34;http://orechou.github.io/2018/09/15/Java-Java-NIO/&#34;&gt;文章&lt;/a&gt;中主要介绍了 Java NIO 相关基础和 Reactor 模式，NIO 的实现在不同的平台上依赖于操作系统所提供的系统调用。下面将介绍 NIO 在 Linux 平台上的底层实现原理。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://orechou.com/2018/Linux-IO-%E5%8E%9F%E7%90%86/&t=Linux IO 原理"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    OreChou
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/book/">Book</a></li><!--
     --><!--
       --><li><a href="/application/">Apps</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'orechou';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
